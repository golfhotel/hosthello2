<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="it"><generator uri="https://jekyllrb.com/" version="4.0.0">Jekyll</generator><link href="https://www.hosthello.com/feed.xml" rel="self" type="application/atom+xml" /><link href="https://www.hosthello.com/" rel="alternate" type="text/html" hreflang="it" /><updated>2021-11-09T01:41:53+01:00</updated><id>https://www.hosthello.com/feed.xml</id><title type="html">Hosthello</title><subtitle>Hosthello sviluppa progetti web con le tecnologie più recenti.
</subtitle><entry><title type="html">Come si usa la funzione rand nel linguaggio C</title><link href="https://www.hosthello.com/posts/how-rand-function-works" rel="alternate" type="text/html" title="Come si usa la funzione rand nel linguaggio C" /><published>2021-11-08T00:00:00+01:00</published><updated>2021-11-08T00:00:00+01:00</updated><id>https://www.hosthello.com/posts/how-rand-function-works</id><content type="html" xml:base="https://www.hosthello.com/posts/how-rand-function-works">&lt;p&gt;Per usare &lt;code class=&quot;highlighter-rouge&quot;&gt;rand()&lt;/code&gt; bisogna inizializzare (basta una volta) il “generatore di numeri random”.&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;//inizializzazione generatore di numeri random&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;srand&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Quando si invoca la funzione &lt;code class=&quot;highlighter-rouge&quot;&gt;rand()&lt;/code&gt; questa restituisce un valore casuale (o random) compreso in un certo intervallo. Se questo intervallo non è definito, si usa un intervallo di default che va da &lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt; a &lt;code class=&quot;highlighter-rouge&quot;&gt;32766&lt;/code&gt;, per cui &lt;code class=&quot;highlighter-rouge&quot;&gt;rand()&lt;/code&gt; restituisce in modo casuale numeri interi che vanno da &lt;strong&gt;0&lt;/strong&gt; a &lt;strong&gt;32766&lt;/strong&gt;. Essendo incluso anche lo &lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt;, il &lt;strong&gt;totale&lt;/strong&gt; dei numeri gestiti da &lt;code class=&quot;highlighter-rouge&quot;&gt;rand()&lt;/code&gt; è &lt;code class=&quot;highlighter-rouge&quot;&gt;32767&lt;/code&gt; (che è diverso da 32766!!!).&lt;/p&gt;

&lt;p&gt;Questo numero totale è chiamato &lt;code class=&quot;highlighter-rouge&quot;&gt;RAND_MAX&lt;/code&gt; interpretabile come la “dimensione” del range.&lt;/p&gt;

&lt;p&gt;Ora sapendo che &lt;code class=&quot;highlighter-rouge&quot;&gt;RAND_MAX&lt;/code&gt; è il totale dei numeri gestibili con la funzione &lt;code class=&quot;highlighter-rouge&quot;&gt;rand()&lt;/code&gt;, possiamo dire che il più piccolo di questo totale di numeri è &lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt; mentre il più grande è &lt;code class=&quot;highlighter-rouge&quot;&gt;RAND_MAX-1&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;n.ro più piccolo      RAND_MAX-1
  ↑                       ↑
+---+---+---+---+-----+-------+
| 0 | 1 | 2 | 3 | ... | 32766 |
+---+---+---+---+-----+-------+
⌊______________________________⌋
               ↓
       RAND_MAX == 32767
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Per capire meglio.&lt;/strong&gt; Se non fosse stato considerato lo &lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt; e si partiva da &lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt;, la dimensione totale (&lt;code class=&quot;highlighter-rouge&quot;&gt;RAND_MAX&lt;/code&gt;) coincideva con il numero più grande del range (che non si sarebbe chiamato &lt;code class=&quot;highlighter-rouge&quot;&gt;RAND_MAX-1&lt;/code&gt; ma &lt;code class=&quot;highlighter-rouge&quot;&gt;RAND_MAX&lt;/code&gt;) .&lt;/p&gt;

&lt;h2 id=&quot;definire-un-intervallo-per-rand&quot;&gt;Definire un intervallo per &lt;code class=&quot;highlighter-rouge&quot;&gt;rand()&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;Se &lt;code class=&quot;highlighter-rouge&quot;&gt;RAND_MAX-1&lt;/code&gt; è il valore random più grande restituito da &lt;code class=&quot;highlighter-rouge&quot;&gt;rand()&lt;/code&gt;, il valore più piccolo è &lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Quindi se non specificato diversamente, la funzione &lt;code class=&quot;highlighter-rouge&quot;&gt;rand()&lt;/code&gt; restituisce un valore casuale da &lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt; a &lt;code class=&quot;highlighter-rouge&quot;&gt;RAND_MAX-1&lt;/code&gt;.&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;//rand() restituisce in n valori casuali da 0 a 32766&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rand&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Il codice sopra può essere scritto anche come il seguente.&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;//RAND_MAX di default vale 32767&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//rand() restituisce valori da 0 a RAND_MAX-1&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//rand() restituisce in n valori casuali da 0 a 32766&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rand&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;32767&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//rand() e rand() % 32767 sono identiche. &lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;È possibile definire un totale &lt;code class=&quot;highlighter-rouge&quot;&gt;RAND_MAX&lt;/code&gt; diverso da quello di default usando il segno &lt;code class=&quot;highlighter-rouge&quot;&gt;%&lt;/code&gt;.&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;//RAND_MAX == 100;&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//rand() restituisce valori da 0 a RAND_MAX-1&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//rand() restituisce in n valori casuali da 0 a 99&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rand&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//  ⌊___________⌋&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//        ├───────────── se (rand() % 100) restituisce 0  , n == 0&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//        └───────────── se (rand() % 100) restituisce 100, n == RAND_MAX-1 == 99&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Genericamente è possibile definire intervalli diversi in questo modo:&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rand&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;max&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;min&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//  ⌊______________⌋&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//         ├───────────── se (rand() % max) restituisce 0    , n == +min&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//         └───────────── se (rand() % max) restituisce max-1, n == (max-1)+min&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//Ricorda che rand() fornisce valori da 0 a RAND_MAX-1&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Vediamo un esempio con i numeri.&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;//Valori tra 5 e 100&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rand&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;96&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//  ⌊_____________⌋&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//         ├───────────── se (rand() % 95) restituisce 0 , n == +5&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//         └───────────── se (rand() % 95) restituisce 95, n == 95+5 == 100&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//Ricorda che rand() fornisce valori da 0 a RAND_MAX-1&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;//Valori tra -100 e 100&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rand&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;201&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//  ⌊______________⌋&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//         ├───────────── se (rand() % 201) restituisce 0  , n == -100&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//         └───────────── se (rand() % 201) restituisce 200, n == 200-100 == 100&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//Ricorda: rand() fornisce valori da 0 a RAND_MAX-1&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;definire-un-intervallo-usando-scanf&quot;&gt;Definire un intervallo usando &lt;code class=&quot;highlighter-rouge&quot;&gt;scanf()&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;Se il range si riceve in input con (es.) &lt;code class=&quot;highlighter-rouge&quot;&gt;scanf()&lt;/code&gt;, bisogna calcolare &lt;code class=&quot;highlighter-rouge&quot;&gt;RAND_MAX&lt;/code&gt;. Per calcolarlo e sufficiente sottrarre dal &lt;code class=&quot;highlighter-rouge&quot;&gt;max&lt;/code&gt; il &lt;code class=&quot;highlighter-rouge&quot;&gt;min&lt;/code&gt; e aggiungere &lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt;.&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;//in generale&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rand&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;max&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;min&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;min&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//             ⌊_____________⌋&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//                    ↓&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//                 RAND_MAX&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Questo medoto vale sempre. Vediamo qualche esempio.&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;//valori inseriti in input tramite scanf() &lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//min == 5 e max == 100.&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//tecnicamente RAND_MAX deve essere 96 ovvero 100-5+1 quindi max-min+1.&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;//Valori tra 5 e 100.&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rand&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//  ⌊________________________⌋&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//              ├───────────── se (rand() % (95 + 1)) restituisce 0 , a == +5&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//              └───────────── se (rand() % (95 + 1)) restituisce 95, a == 95 + 5 == 101&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//Ricorda che rand() restituisce valori da 0 a RAND_MAX-1&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;//valori inseriti in input tramite scanf() &lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//min == -100 e max == 100.&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//tecnicamente RAND_MAX deve essere 201 ovvero 100-(-100)+1 quindi max-min+1.&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;//Valori tra -100 e 100.&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rand&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//  ⌊_____________________________⌋&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//              ├───────────── se (rand() % (100 - (-100) +1)) restituisce 0  , a == -100&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//              └───────────── se (rand() % (100 - (-100) +1)) restituisce 200, a == 200 - 100 == 100&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//RAND_MAX == (100 - (-100) +1) == 201&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//Ricorda: rand() restituisce valori da 0 a RAND_MAX-1&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>Ivan Garrini</name></author><summary type="html">Per usare rand() bisogna inizializzare (basta una volta) il “generatore di numeri random”.</summary></entry><entry><title type="html">Cos’è il Deadlock e come prevenirlo</title><link href="https://www.hosthello.com/posts/cosa-e-il-deadlock" rel="alternate" type="text/html" title="Cos'è il Deadlock e come prevenirlo" /><published>2021-11-08T00:00:00+01:00</published><updated>2021-11-08T00:00:00+01:00</updated><id>https://www.hosthello.com/posts/cosa-e-il-deadlock</id><content type="html" xml:base="https://www.hosthello.com/posts/cosa-e-il-deadlock">&lt;p&gt;&lt;img src=&quot;https://images.unsplash.com/photo-1509558741973-0cd2f6a12a4f?ixlib=rb-1.2.1&amp;amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;amp;auto=format&amp;amp;fit=crop&amp;amp;w=730&amp;amp;q=70&quot; alt=&quot;Il deadlock è come un mostro nascosto&quot; title=&quot;Il deadlock è come un mostro nascosto&quot; /&gt;&lt;/p&gt;

&lt;p&gt;I &lt;strong&gt;deadlock&lt;/strong&gt; nascono per problemi di &lt;em&gt;progettazione sbagliata della sincronizzazione tra processi&lt;/em&gt;. In un sistema in cui vari processi usano delle &lt;strong&gt;&lt;em&gt;risorse condivise&lt;/em&gt;&lt;/strong&gt; può verificarsi deadlock tra processi concorrenti se il programmatore commette qualche errore nello schema di utilizzo risorse &lt;strong&gt;richiesta ➡ utilizzo ➡ rilascio&lt;/strong&gt;.&lt;/p&gt;

&lt;h2 id=&quot;cosa-vuol-dire-deadlock&quot;&gt;Cosa vuol dire deadlock?&lt;/h2&gt;

&lt;p&gt;Spesso un processo che possiede una o più risorse non le rilascia fin quando non completa l’esecuzione. Spesso per completare l’esecuzione un processo ha bisogno di altre risorse (oltre quelle che già possiede). Questo scenario porta ad una situazione in cui un gruppo di processi si mette in attesa di una risorsa occupata che non potrà mai essere acquisita perchè il processo che la occupa deve acquisire altre risorse occupate prima di rilasciare quella che già ha in uso. Le risorse restano bloccate all’interno di uno loop: un circolo di richiesta-attesa insoddisfatto in cui nessuno si muove e tutti attendono. Un deadlock può interferire sull’esecuzione di parti di programma/i, di un intero programma/i fino ad un intero sistema.&lt;/p&gt;

&lt;h2 id=&quot;stati-pronto-esecuzione-attesa&quot;&gt;Stati PRONTO-ESECUZIONE-ATTESA&lt;/h2&gt;

&lt;p&gt;Un processo è “vivo” (interagisce, esegue, richiede qualcosa ecc..) quando è in stato di ESECUZIONE (quindi fa uso della CPU). Lo stesso processo durante la sua esecuzione può aver bisogno di una risorsa. La risorsa spesso non è disponibile.&lt;/p&gt;

&lt;p&gt;Quando il processo fa richiesta di risorsa, la risorsa se non disponibile “mette in ATTESA” il processo (fa passare involontariamente il processo nello stato di attesa) perchè diversamente il processo non può portare avanti l’esecuzione.&lt;/p&gt;

&lt;p&gt;Far richiesta di una risorsa (aver bisogno di una risorsa) fa spostare automaticamente il processo dallo stato di ESECUZIONE allo stato di ATTESA.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;br /&gt;Se sto chiedendo una risorsa sono nello stato di ATTESA.&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Se sto usando una risorsa posso essere nello stato di ESECUZIONE se è in corso il mio “time slice”, oppure posso essere nello stato PRONTO (ready-queue) per poi passare successivamente nello stato di ESECUZIONE quando una risorsa sarà libera: le regole di scheduling-CPU gestiscono il passaggio &lt;strong&gt;pronto ➡ esecuzione&lt;/strong&gt;.&lt;/p&gt;

&lt;h2 id=&quot;quando-si-verifica-il-deadlock&quot;&gt;Quando si verifica il deadlock&lt;/h2&gt;

&lt;p&gt;Affinché si verifichi un deadlock devono verificarsi &lt;strong&gt;contemporaneamente&lt;/strong&gt; 4 condizioni necessarie: necessarie vuol dire che se le 4 condizioni si verificano contemporaneamente &lt;em&gt;potrebbe&lt;/em&gt; verificarsi uno stallo (deadlock). Ma è anche vero che potrebbe non verificarsi nessun deaclock.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;br /&gt;Se anche una delle 4 condizioni manca, è sicuro che non c’è deadlock! &lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Le 4 condizioni che realizzano un potenziale deadlock sono:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;mutua esclusione (mutual exclusion)&lt;/strong&gt; lavoro mutuamente esclusivo tra i processi: la risorsa è utilizzabile da un solo processo alla volta.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;nessun rilascio anticipato (no pre-emption)&lt;/strong&gt; se un processo ha acquisito una risorsa nessuno me gliela può togliere (è il processo che la
lascia quando non gli serve più)&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;attesa circolare (circular wait)&lt;/strong&gt; deve esserci un’attesa circolare in cui ogni processo aspetta una risorsa in possesso di un altro processo&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;possesso e attesa (hold &amp;amp; wait)&lt;/strong&gt; deve esserci la condizione hold-and-wait ovvero il processo detiene già le risorse ma non può andar avanti perchè ne vuole altre per continuare l’esecuzione: quindi il processo è in uno stato di ATTESA con in possesso delle risorse che effettivamente tiene bloccate per se, quindi inutilizzabili da altri processi&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Se queste 4 condizioni sono verificate, può verificarsi un deadklock.&lt;/p&gt;

&lt;h2 id=&quot;gestire-il-problema-del-deadlock&quot;&gt;Gestire il problema del deadlock&lt;/h2&gt;

&lt;p&gt;I modi per &lt;strong&gt;uscire&lt;/strong&gt; da un deadlock (gestire il problema deadlock) sono di 2 tipi, &lt;em&gt;prevenzione&lt;/em&gt; e &lt;em&gt;rilevazione-ripristino&lt;/em&gt;:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;prevenzione&lt;/strong&gt; garantisce che il deadlock non si verificherà mai. Prevenire vuol dire &lt;em&gt;garantire&lt;/em&gt; che almeno una delle 4 condizioni, che provocano lo stallo, &lt;strong&gt;non&lt;/strong&gt; si verifichi. Le risorse libere tendono a non essere utilizzate per la “paura” di incorrere in una delle 4 condizioni precedenti. Importante notare che per &lt;strong&gt;realizzare&lt;/strong&gt; un metodo di prevenzione è necessario sprecare anche in questo caso delle risorse (risorse che servono per realizzare il metodo di prevenzione). Ciò, oltre ad aumentare la complessità di gestione dei processi, produce uno scarso utilizzo dei dispositivi e riduce la produttività.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;rilevazione-ripristino&lt;/strong&gt; notifica l’utente che il deadlock può verificarsi e quando si verifica in qualche
modo l’utente se ne accorge e lo risolve. &lt;strong&gt;Risolvere&lt;/strong&gt; vuol dire fare un &lt;strong&gt;roll-back&lt;/strong&gt; su uno o più processi.
Roll-back vuol dire perdere il lavoro fatto fino al verificarsi del deadlock, quindi aver sprecato tempo
e uso delle risorse.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Quindi in entrambi i casi ci sono vantaggi e svantaggi.&lt;/p&gt;

&lt;div style=&quot;border: solid 1px #aaa; padding: 3em; padding-top: 1.5em; padding-bottom: 1.5em; margin-top: 2em; margin-bottom: 2em;&quot;&gt;

  &lt;h3 id=&quot;deadlock-e-ambienti-safaty-critical-e-non-safety-critical&quot;&gt;Deadlock e ambienti safaty-critical e non safety-critical.&lt;/h3&gt;

  &lt;p&gt;La prevenzione è una situazione fondamentale nei sistemi &lt;strong&gt;“safety-critical”&lt;/strong&gt; dove è necessario che i processi vengano eseguiti fino alla loro conclusione (es: partenza shuttle, transazioni ATM, sistema raffreddamento nocciolo reattore nucleare ecc…). In questi sistemi, anche se ha un costo, la prevenzione deve essere fatta perchè diversamente non si hanno soluzioni.&lt;/p&gt;

  &lt;blockquote&gt;
    &lt;p&gt;&lt;br /&gt;La prevenzione garantisce di non incorrere in deadlock!&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
  &lt;/blockquote&gt;

  &lt;p&gt;Se il sistema è &lt;strong&gt;non safety-critical&lt;/strong&gt; posso preferire le prestazioni lasciando che il sistema usi tutte le risorse disponibili, poi quando si verifica il deadlock si farà roll-back (perderò il lavoro fatto dalla comparsa del deadlock).&lt;/p&gt;

  &lt;p&gt;In contesti dove il deadlock non è assolutamente critico vi è la possibilità di usare l’&lt;strong&gt;algoritmo dello struzzo&lt;/strong&gt;, ovvero l’utente che si accorge di un deadlock può “uccidere” un processo o nel peggiore dei casi riavviare il sistema.&lt;/p&gt;
&lt;/div&gt;

&lt;h3 id=&quot;prevenzione-come-realizzarla-per-evitare-il-deadlock&quot;&gt;Prevenzione: come realizzarla per evitare il deadlock&lt;/h3&gt;

&lt;p&gt;Per prevenire il deadlock ci sono 2 strategie, la prevenzione statica e quella dinamica:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;prevenzione statica&lt;/strong&gt; è una regola in cui tutti i processi devono sottostare, indipendentemente dalle richieste del processo. Da subito il processo deve seguire le regole della prevenzione statica, che lavora per &lt;strong&gt;&lt;em&gt;realizzare la violazione di una delle 4 condizioni che portano a deadlock&lt;/em&gt;&lt;/strong&gt; (in realtà sono violabili solo 3 condizioni perchè la mutua esclusione non può essere violata, per cui si lavora solo sulle 3 condizioni restanti):&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;
        &lt;p&gt;realizzare la prevenzione statica per prevenire la condizione &lt;strong&gt;hold-and-wait&lt;/strong&gt; si attua imponendo al processo di prendere &lt;strong&gt;tutte&lt;/strong&gt; le risorse (necessarie per portare a termine l’esecuzione) prima di iniziare la sua esecuzione. Quindi si ha solo l’evento “hold” (tenere) delle risorse, mentre il “wait” non si verificherà perchè le risorse sono già a disposizione del processo (avendole già prese prima di iniziare la sua esecuzione). Può provocare &lt;strong&gt;starvation&lt;/strong&gt;, ossia che il processo in esecuzione ci rimane per lungo tempo, non liberando così le risorse necessarie anche ad altri processi.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;realizzare la prevenzione statica per evitare il vincolo del &lt;strong&gt;non-premptive&lt;/strong&gt; sulle risorse (usare le risorse fino a quando il processo vuole), ovvero se il processo va in stato di ATTESA deve lasciare tutte le risorse che aveva acquisito.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;realizzare la prevenzione statica per prevenire la &lt;strong&gt;circolarità&lt;/strong&gt; gestendo le risorse con ordine monotono di priorità. In pratica &lt;strong&gt;ad ogni risorsa viene assegnata una priorità di esecuzione&lt;/strong&gt; mentre &lt;strong&gt;ad ogni processo viene imposto di chiedere le risorse seguendo un ordine crescente di numerazione&lt;/strong&gt;. Quindi all’inizio un processo può chiedere una risorsa con qualsiasi numero di priorità e succesivamente può richiedere un’altra risorsa solo se quest’ultima ha un valore di priorità maggiore.&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ol&gt;

    &lt;p&gt;Con la prevenzione statica si ha un &lt;strong&gt;basso uso delle risorse&lt;/strong&gt; (per via dei modi con cui si accede alle risorse per realizzare la prevenzione).&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;prevenzione dinamica&lt;/strong&gt; analizza caso per caso. &lt;strong&gt;&lt;em&gt;Ogni richiesta fatta dal processore viene valutata&lt;/em&gt;&lt;/strong&gt; e si decide a run-time come comportarsi. Prevede 2 tipi di &lt;strong&gt;valutazione&lt;/strong&gt; delle richieste:&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;
        &lt;p&gt;valutazione con &lt;strong&gt;algoritmo con RAG&lt;/strong&gt; (grafo ciclico delle risorse): è un aloritmo che prevede L’USO DEL RAG. È efficiente (risponde velocemente) ma funziona solo se si ha &lt;strong&gt;&lt;em&gt;un’unica istanza per ogni tipo di risorsa&lt;/em&gt;&lt;/strong&gt;; diversamente non è utilizzabile. Al processo si concede una risorsa solo se questa non crea un loop (ciclo di richiesta risorse che &lt;strong&gt;potenzialmente porta a deadlock&lt;/strong&gt;, quindi siamo in uno stato &lt;strong&gt;non-sicuro&lt;/strong&gt;). Oltre agli &lt;em&gt;archi di richiesta&lt;/em&gt; ed &lt;em&gt;assegnazione&lt;/em&gt; tipici del RAG, l’algoritmo usa un &lt;strong&gt;&lt;em&gt;arco di reclamo&lt;/em&gt;&lt;/strong&gt; (linea tratteggiata) dove indica che il processo può richiedere la risorsa in qualsiasi momento (non si tratta quindi di una iniziativa di richiesta ma indica una potenziale possibilità di ottenere la risorsa se le condizioni permettono di non creare un loop). Assegnare o meno la risorsa è compito dell’algoritmo. La linea tratteggiata va dal processo alla risorsa e si inverte la direzione (diventando linea continua) se la risorsa viene poi assegnata al processo (qui ci troviamo in uno stato &lt;strong&gt;sicuro&lt;/strong&gt;). Il reclamo di una risorsa va fatto prima che il processo entri in esecuzione.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;valutazione con &lt;strong&gt;algoritmo del banchiere&lt;/strong&gt;: ha maggiore complessità (quindi risponde più lentamente) e si usa in un contesto &lt;strong&gt;dove il numero di istanze per ogni tipo di risorsa può essere maggiore di 1&lt;/strong&gt; (situazione più generica). L’algoritmo è composto da 2 tipi di algoritmi:&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;&lt;strong&gt;algoritmo di allocazione&lt;/strong&gt;&lt;/li&gt;
          &lt;li&gt;&lt;strong&gt;algoritmo di verifica dello stato&lt;/strong&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ol&gt;

    &lt;p&gt;Entrambe gli approcci (“algoritmo con RAG” e “algoritmo del banchiere”) richiede a priori che il SO &lt;strong&gt;conosca esattamente il n.ro massimo di risorse&lt;/strong&gt; che ogni processo userà durante la sua vita nel caso pessimo (= caso in cui dovrà sfruttare il n.ro massimo di risorse per terminare l’esecuzione).&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;&lt;br /&gt;Nella prevenzione dinamica il SO conosce esattamente il n° max di risorse che il processo userà da inizio a fine esecuzione! &lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;p&gt;Purtroppo conoscere a priori le risorse che un processo andrà ad usare durante la sua vita, è un’informazione che spesso non è nota. Perciò &lt;strong&gt;non è possibile usare algoritmo con RAG o il banchiere&lt;/strong&gt; in programmi che possono cambiare durante l’esecuzione a seconda degli input provenienti dall’esterno, ovvero di programmi che avanzino la possibilità che un processo possa chiedere poche o tante risorse. Sono quindi algoritmi poco usati.&lt;/p&gt;

    &lt;p&gt;Anche l’uso della prevenzione dinamica ha &lt;strong&gt;basso uso delle risorse&lt;/strong&gt;.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;div style=&quot;border: solid 1px #aaa; padding: 3em; padding-top: 1.5em; padding-bottom: 1.5em; margin-top: 2em; margin-bottom: 2em;&quot;&gt;

  &lt;h3 id=&quot;rag-approfondimento&quot;&gt;RAG (approfondimento).&lt;/h3&gt;

  &lt;p&gt;Il RAG è un modo grafico per poter rappresentare/descrivere le situzioni di stallo. Il RAG è un insieme di nodi e archi.
I nodi posso collegarsi tra loro tramite l’uso degli archi. L’immagine sotto è un esempio di deadlock!&lt;/p&gt;

  &lt;p&gt;&lt;img src=&quot;../img/rag.jpg&quot; alt=&quot;alt text&quot; title=&quot;Logo Title Text 1&quot; /&gt;&lt;/p&gt;

  &lt;p&gt;I nodi (insieme &lt;strong&gt;V&lt;/strong&gt;) sono costituiti da:&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;&lt;strong&gt;cerchi&lt;/strong&gt; = processi (CPU; I/O, memoria)&lt;/li&gt;
    &lt;li&gt;&lt;strong&gt;rettangoli&lt;/strong&gt; = risorse. Ogni risorsa ha un pallino rappresentante l’istanza: 2 pallini = 2 istanze della risorsa.&lt;/li&gt;
  &lt;/ul&gt;

  &lt;p&gt;Gli archi (insieme &lt;strong&gt;E&lt;/strong&gt;) possono direzionarsi cosi:&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;da processo a risorsa: vuol dire che il processo sta richiedendo una risorsa.&lt;/li&gt;
    &lt;li&gt;da risorsa a processo: vuol dire che il processo detiene una risorsa.&lt;/li&gt;
  &lt;/ul&gt;

  &lt;p&gt;Dall’immagine sopra si ha che:&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;V = {(P1,P2,P3), (R1,R2,R3,R4)}&lt;/code&gt;&lt;/li&gt;
    &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;E = {(R1,P2), (P1,R1), (R2,P1),(R2,P2), (R3,P3),(P2,R3)}&lt;/code&gt;&lt;/li&gt;
  &lt;/ul&gt;

  &lt;p&gt;ma la relazione tra i nodi (la direzione degli archi), può cambiare in fase di &lt;strong&gt;richiesta-&amp;gt;acquisizione-&amp;gt;rilascio&lt;/strong&gt; delle risorse.&lt;/p&gt;

  &lt;h3 id=&quot;stato-sicuro-e-stato-non-sicuro-approfondimento&quot;&gt;Stato sicuro e stato non-sicuro (approfondimento).&lt;/h3&gt;

  &lt;p&gt;Il sistema si trova in uno stato sicuro (&lt;strong&gt;safe&lt;/strong&gt;) se le risorse sono assegnate ai processi senza che si verifichi il deadlock (viene garantita che non si verifichi la condizione di &lt;em&gt;circula wait&lt;/em&gt;, una delle 4 condizioni da violare per evitare il deadlock). In parole povere è una sequenza di allocazione risorse che permette a tutti i processi di usare le risorse per &lt;strong&gt;poter terminare la loro esecuzione&lt;/strong&gt;. Le risorse, che verranno assegnate con una certa sequenza, andranno a formare una &lt;strong&gt;sequenza sicura&lt;/strong&gt; di esecuzione processi.&lt;/p&gt;

  &lt;p&gt;Se non esite una &lt;em&gt;sequenza sicura&lt;/em&gt; allora il sistema si trova in uno stato non sicuro (&lt;strong&gt;unsafe&lt;/strong&gt;). Una sequenza di processi può vivere in uno &lt;em&gt;stato non sicuro&lt;/em&gt; senza cadere in deadlock, ma potrebbe anche incontrare un deadlock senza preavviso.&lt;/p&gt;

  &lt;blockquote style=&quot;border: solid 1px #00b8d4; border-left: 5px solid #00b8d4; background: #00b8d40a; padding: 20px; border-radius: 5px; font-size: 14px;&quot;&gt;
    &lt;p&gt;Definire una sequenza sicura o non sicura è compito degli algoritmi di &lt;strong&gt;prevenzione dinamica&lt;/strong&gt; (&lt;em&gt;algoritmo con RAG&lt;/em&gt; e &lt;em&gt;algoritmo del banchiere&lt;/em&gt;) .&lt;/p&gt;
  &lt;/blockquote&gt;

  &lt;p&gt;Una sequenza di processi è una &lt;em&gt;sequenza sicura&lt;/em&gt; quando &lt;strong&gt;ogni&lt;/strong&gt; processo della sequenza può &lt;em&gt;richiedere e ottenere&lt;/em&gt; una o più risorse e, una volta ottenute, terminare. Le risorse, che il processo può richiedere e ottenere, sono quelle disponibili (non assegnate a nessuno) più quelle del processo che, avendo terminato prima di lui l’esecuzione, ha liberato le risorse usate. Se un processo non trova le risorse libere, può rimanere in attesa e prendere le risorse quando disponibili, perchè in questo contesto prima o poi si libereranno dato che non esiste l’attesa circolare.&lt;/p&gt;

  &lt;blockquote style=&quot;border: solid 1px #00b8d4; border-left: 5px solid #00b8d4; background: #00b8d40a; padding: 20px; border-radius: 5px; font-size: 14px;&quot;&gt;
    &lt;p&gt;Una sequenza safe (sicura) non porterà &lt;strong&gt;mai&lt;/strong&gt; a deadlock perchè viene violata la condizione di attesa circolare (circular wait), che non si verificherà.&lt;/p&gt;
  &lt;/blockquote&gt;

  &lt;p&gt;Ricordiamo che si tratta di &lt;em&gt;prevenzione dinamica&lt;/em&gt; in cui il SO conosce a priori il n.ro massimo di risorse che ogni processo userà durante la sua vita. Per cui quando si è in uno stato non-sicuro il SO non riesce ad impedire al processo di chiedere le risorse per raggiungere il massimo dichiarato. Questo comportamento potrebbe condurre al deadlock perchè ciò che accade nello stato non-sicuro dipende da come si comporta il processo stesso quando rilascia o richiede risorse.&lt;/p&gt;

  &lt;blockquote style=&quot;border: solid 1px #00b8d4; border-left: 5px solid #00b8d4; background: #00b8d40a; padding: 20px; border-radius: 5px; font-size: 14px;&quot;&gt;
    &lt;p&gt;Non tutti gli stati unsafe (non-sicuri) portano a deaklock, ma da uno stato &lt;em&gt;unsafe&lt;/em&gt; posso andare in deadlock.&lt;/p&gt;
  &lt;/blockquote&gt;

  &lt;p&gt;&lt;img src=&quot;../img/deadlock-safe-unsafe.jpg&quot; alt=&quot;deadlock-safe-unsafe.jpg&quot; title=&quot;deadlock-safe-unsafe.jpg&quot; /&gt;&lt;/p&gt;

&lt;/div&gt;

&lt;h3 id=&quot;rilevazione-ripristino-scovare-il-deadlock-e-ripristinare-il-sistema&quot;&gt;Rilevazione-ripristino: scovare il deadlock e ripristinare il sistema.&lt;/h3&gt;

&lt;p&gt;Quando un SO &lt;strong&gt;non fa uso&lt;/strong&gt; degli algoritmi di prevenzione vuol dire che non previene il deadlock e può incontrarlo in qualsiasi momento. Se il deadlock interferisce su parte del sistema, senza bloccarlo completamente, si può agire come segue rilevando il deadlock e successivamente ripristinaer il sistema:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Rilevazione&lt;/strong&gt;. Usare un algoritmo che sia in grado di &lt;strong&gt;rilevare&lt;/strong&gt; il deadlock, esaminando il sistema.&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;Rilevazione e ripristino tramite RAG&lt;/strong&gt; (istanza singola di ciascun tipo di risorsa): funziona correttamente solo se tutte le risorse del sistema hanno &lt;strong&gt;una sola istanza&lt;/strong&gt; (come nella &lt;em&gt;prevenzione dinamica&lt;/em&gt;). Per individuare un deadlock si va ad analizzare una variante del RAG chiamato &lt;strong&gt;grafo di attesa&lt;/strong&gt; che a differenza del RAG contiene solo i processi collegati tra loro dagli archi: non ci sono i nodi delle risorse. Il sistema &lt;em&gt;mantiene costantemente aggiornato&lt;/em&gt; il grafo di attesa. Durante l’analisi è &lt;em&gt;invocato periodicamente un algoritmo&lt;/em&gt; per cercare un ciclo all’interno del RAG.&lt;/p&gt;

        &lt;blockquote style=&quot;border: solid 1px #00b8d4; border-left: 5px solid #00b8d4; background: #00b8d40a; padding: 20px; border-radius: 5px; font-size: 14px;&quot;&gt;
          &lt;p&gt;Un vantaggio di questo metodo è il &lt;strong&gt;non dover conoscere in anticipo&lt;/strong&gt; richieste necessarie. &lt;br /&gt;
  Uno svantaggio è il costo elevato del recovery.&lt;/p&gt;
        &lt;/blockquote&gt;
      &lt;/li&gt;
    &lt;/ul&gt;

 	Nell’immagine sotto: (a) RAG - (b) Grafo di attesa risorse

 	&lt;img src=&quot;../img/rag-e-grafo-attesa.jpg&quot; alt=&quot;Rag e grafo d'attesa&quot; title=&quot;rag-e-grafo-attesa.jpg&quot; /&gt;

    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;Algoritmo di rilevazione&lt;/strong&gt; (più istanze di ciascun tipo di risorsa): se vi è più di una istanza per risorsa, non è possibile usare l’algoritomo &lt;em&gt;Rilevazione e ripristino tramite RAG&lt;/em&gt;, ma si usa l’&lt;em&gt;algoritmo di rilevazione&lt;/em&gt;. Questi verifica tutte le possibili sequenze di assegnazione risorse per i processi che non hanno ancora terminato. Se a fine verifica si ha una &lt;em&gt;sequenza safe&lt;/em&gt; non ci sarà deadlock. È simile all’&lt;em&gt;algoritmo del banchiere&lt;/em&gt;.&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;L’&lt;em&gt;algoritmo di rilevazione&lt;/em&gt; si usa considerando la presunta &lt;strong&gt;frequenza&lt;/strong&gt; con la quale un deadlock si verifica e il &lt;strong&gt;numero&lt;/strong&gt; dei processi influenzati da un deadlock. Viene richiamato ad &lt;strong&gt;ogni richiesta risorsa&lt;/strong&gt; e, come altrnativa meno dispensiosa, potrebbe essere richiamato ad &lt;strong&gt;intervalli di tempo&lt;/strong&gt; oppure quando si hauna drastica riduzione dell’uso CPU dovuto ad un deadlock (che di norma rende inefficiente le prestazioni del sistema).&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Ripristino&lt;/strong&gt;. Usare un algoritmo che in caso di deadlock, &lt;strong&gt;riporti il sistema ad uno stato precedente&lt;/strong&gt; al deadlock.&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;Terminazione dei processi&lt;/strong&gt; (uccisione): è possibile terminare &lt;strong&gt;tutti i processi&lt;/strong&gt; per interrompe il deadlock ma si perde il lavoro (magari di molti calcoli) già svolto dai processi ed inoltre se il processo prima del deadlock stava aggiornando un programma o un file, terminare vuol dire comprometterne l’uso. È possibile anche terminare un &lt;strong&gt;processo alla volta&lt;/strong&gt; fin quando il deadlock viene interrotto, ma si genera &lt;em&gt;overhead&lt;/em&gt; perchè ad ogni terminazione processo bisogna invocare l’&lt;em&gt;algoritmo di rilevazione&lt;/em&gt; per vedere se ci sono altri processi che provocano deadlock.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;Prelazione delle risorse dai processi bloccati nel deadlock&lt;/strong&gt;: è possibile sottrarre le risorse in successione a processi &lt;strong&gt;selezionati&lt;/strong&gt; e darle ad altri processi in modo da interrompere il deadlock. Si selezionano perché è necessario capire come gestire il processo che subisce la prelazione, dal momento che perderebbe tutto il lavoro fatto risultando essere uno spreco di risorsa. Inoltre bisogna definire se salvare lo stato del processo da prelazionare (rollback), in modo da riprenderlo sucessivamente, o se terminare il processo e riavviarlo in seguito. Il rollback è efficace ma dispendioso in risorse. Per finire bisogna assicurare che le risorse non vengano sottratte sempre allo stesso processo.&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;</content><author><name>Ivan Garrini</name></author><summary type="html">I deadlock nascono per problemi di progettazione sbagliata della sincronizzazione tra processi. In un sistema in cui vari processi usano delle risorse condivise può verificarsi deadlock tra processi concorrenti se il programmatore commette qualche errore nello schema di utilizzo risorse richiesta ➡ utilizzo ➡ rilascio. Cosa vuol dire deadlock? Spesso un processo che possiede una o più risorse non le rilascia fin quando non completa l’esecuzione. Spesso per completare l’esecuzione un processo ha bisogno di altre risorse (oltre quelle che già possiede). Questo scenario porta ad una situazione in cui un gruppo di processi si mette in attesa di una risorsa occupata che non potrà mai essere acquisita perchè il processo che la occupa deve acquisire altre risorse occupate prima di rilasciare quella che già ha in uso. Le risorse restano bloccate all’interno di uno loop: un circolo di richiesta-attesa insoddisfatto in cui nessuno si muove e tutti attendono. Un deadlock può interferire sull’esecuzione di parti di programma/i, di un intero programma/i fino ad un intero sistema. Stati PRONTO-ESECUZIONE-ATTESA Un processo è “vivo” (interagisce, esegue, richiede qualcosa ecc..) quando è in stato di ESECUZIONE (quindi fa uso della CPU). Lo stesso processo durante la sua esecuzione può aver bisogno di una risorsa. La risorsa spesso non è disponibile. Quando il processo fa richiesta di risorsa, la risorsa se non disponibile “mette in ATTESA” il processo (fa passare involontariamente il processo nello stato di attesa) perchè diversamente il processo non può portare avanti l’esecuzione. Far richiesta di una risorsa (aver bisogno di una risorsa) fa spostare automaticamente il processo dallo stato di ESECUZIONE allo stato di ATTESA. Se sto chiedendo una risorsa sono nello stato di ATTESA. Se sto usando una risorsa posso essere nello stato di ESECUZIONE se è in corso il mio “time slice”, oppure posso essere nello stato PRONTO (ready-queue) per poi passare successivamente nello stato di ESECUZIONE quando una risorsa sarà libera: le regole di scheduling-CPU gestiscono il passaggio pronto ➡ esecuzione. Quando si verifica il deadlock Affinché si verifichi un deadlock devono verificarsi contemporaneamente 4 condizioni necessarie: necessarie vuol dire che se le 4 condizioni si verificano contemporaneamente potrebbe verificarsi uno stallo (deadlock). Ma è anche vero che potrebbe non verificarsi nessun deaclock. Se anche una delle 4 condizioni manca, è sicuro che non c’è deadlock! Le 4 condizioni che realizzano un potenziale deadlock sono: mutua esclusione (mutual exclusion) lavoro mutuamente esclusivo tra i processi: la risorsa è utilizzabile da un solo processo alla volta. nessun rilascio anticipato (no pre-emption) se un processo ha acquisito una risorsa nessuno me gliela può togliere (è il processo che la lascia quando non gli serve più) attesa circolare (circular wait) deve esserci un’attesa circolare in cui ogni processo aspetta una risorsa in possesso di un altro processo possesso e attesa (hold &amp;amp; wait) deve esserci la condizione hold-and-wait ovvero il processo detiene già le risorse ma non può andar avanti perchè ne vuole altre per continuare l’esecuzione: quindi il processo è in uno stato di ATTESA con in possesso delle risorse che effettivamente tiene bloccate per se, quindi inutilizzabili da altri processi Se queste 4 condizioni sono verificate, può verificarsi un deadklock. Gestire il problema del deadlock I modi per uscire da un deadlock (gestire il problema deadlock) sono di 2 tipi, prevenzione e rilevazione-ripristino: prevenzione garantisce che il deadlock non si verificherà mai. Prevenire vuol dire garantire che almeno una delle 4 condizioni, che provocano lo stallo, non si verifichi. Le risorse libere tendono a non essere utilizzate per la “paura” di incorrere in una delle 4 condizioni precedenti. Importante notare che per realizzare un metodo di prevenzione è necessario sprecare anche in questo caso delle risorse (risorse che servono per realizzare il metodo di prevenzione). Ciò, oltre ad aumentare la complessità di gestione dei processi, produce uno scarso utilizzo dei dispositivi e riduce la produttività. rilevazione-ripristino notifica l’utente che il deadlock può verificarsi e quando si verifica in qualche modo l’utente se ne accorge e lo risolve. Risolvere vuol dire fare un roll-back su uno o più processi. Roll-back vuol dire perdere il lavoro fatto fino al verificarsi del deadlock, quindi aver sprecato tempo e uso delle risorse. Quindi in entrambi i casi ci sono vantaggi e svantaggi. Deadlock e ambienti safaty-critical e non safety-critical. La prevenzione è una situazione fondamentale nei sistemi “safety-critical” dove è necessario che i processi vengano eseguiti fino alla loro conclusione (es: partenza shuttle, transazioni ATM, sistema raffreddamento nocciolo reattore nucleare ecc…). In questi sistemi, anche se ha un costo, la prevenzione deve essere fatta perchè diversamente non si hanno soluzioni. La prevenzione garantisce di non incorrere in deadlock! Se il sistema è non safety-critical posso preferire le prestazioni lasciando che il sistema usi tutte le risorse disponibili, poi quando si verifica il deadlock si farà roll-back (perderò il lavoro fatto dalla comparsa del deadlock). In contesti dove il deadlock non è assolutamente critico vi è la possibilità di usare l’algoritmo dello struzzo, ovvero l’utente che si accorge di un deadlock può “uccidere” un processo o nel peggiore dei casi riavviare il sistema. Prevenzione: come realizzarla per evitare il deadlock Per prevenire il deadlock ci sono 2 strategie, la prevenzione statica e quella dinamica: prevenzione statica è una regola in cui tutti i processi devono sottostare, indipendentemente dalle richieste del processo. Da subito il processo deve seguire le regole della prevenzione statica, che lavora per realizzare la violazione di una delle 4 condizioni che portano a deadlock (in realtà sono violabili solo 3 condizioni perchè la mutua esclusione non può essere violata, per cui si lavora solo sulle 3 condizioni restanti): realizzare la prevenzione statica per prevenire la condizione hold-and-wait si attua imponendo al processo di prendere tutte le risorse (necessarie per portare a termine l’esecuzione) prima di iniziare la sua esecuzione. Quindi si ha solo l’evento “hold” (tenere) delle risorse, mentre il “wait” non si verificherà perchè le risorse sono già a disposizione del processo (avendole già prese prima di iniziare la sua esecuzione). Può provocare starvation, ossia che il processo in esecuzione ci rimane per lungo tempo, non liberando così le risorse necessarie anche ad altri processi. realizzare la prevenzione statica per evitare il vincolo del non-premptive sulle risorse (usare le risorse fino a quando il processo vuole), ovvero se il processo va in stato di ATTESA deve lasciare tutte le risorse che aveva acquisito. realizzare la prevenzione statica per prevenire la circolarità gestendo le risorse con ordine monotono di priorità. In pratica ad ogni risorsa viene assegnata una priorità di esecuzione mentre ad ogni processo viene imposto di chiedere le risorse seguendo un ordine crescente di numerazione. Quindi all’inizio un processo può chiedere una risorsa con qualsiasi numero di priorità e succesivamente può richiedere un’altra risorsa solo se quest’ultima ha un valore di priorità maggiore. Con la prevenzione statica si ha un basso uso delle risorse (per via dei modi con cui si accede alle risorse per realizzare la prevenzione). prevenzione dinamica analizza caso per caso. Ogni richiesta fatta dal processore viene valutata e si decide a run-time come comportarsi. Prevede 2 tipi di valutazione delle richieste: valutazione con algoritmo con RAG (grafo ciclico delle risorse): è un aloritmo che prevede L’USO DEL RAG. È efficiente (risponde velocemente) ma funziona solo se si ha un’unica istanza per ogni tipo di risorsa; diversamente non è utilizzabile. Al processo si concede una risorsa solo se questa non crea un loop (ciclo di richiesta risorse che potenzialmente porta a deadlock, quindi siamo in uno stato non-sicuro). Oltre agli archi di richiesta ed assegnazione tipici del RAG, l’algoritmo usa un arco di reclamo (linea tratteggiata) dove indica che il processo può richiedere la risorsa in qualsiasi momento (non si tratta quindi di una iniziativa di richiesta ma indica una potenziale possibilità di ottenere la risorsa se le condizioni permettono di non creare un loop). Assegnare o meno la risorsa è compito dell’algoritmo. La linea tratteggiata va dal processo alla risorsa e si inverte la direzione (diventando linea continua) se la risorsa viene poi assegnata al processo (qui ci troviamo in uno stato sicuro). Il reclamo di una risorsa va fatto prima che il processo entri in esecuzione. valutazione con algoritmo del banchiere: ha maggiore complessità (quindi risponde più lentamente) e si usa in un contesto dove il numero di istanze per ogni tipo di risorsa può essere maggiore di 1 (situazione più generica). L’algoritmo è composto da 2 tipi di algoritmi: algoritmo di allocazione algoritmo di verifica dello stato Entrambe gli approcci (“algoritmo con RAG” e “algoritmo del banchiere”) richiede a priori che il SO conosca esattamente il n.ro massimo di risorse che ogni processo userà durante la sua vita nel caso pessimo (= caso in cui dovrà sfruttare il n.ro massimo di risorse per terminare l’esecuzione). Nella prevenzione dinamica il SO conosce esattamente il n° max di risorse che il processo userà da inizio a fine esecuzione! Purtroppo conoscere a priori le risorse che un processo andrà ad usare durante la sua vita, è un’informazione che spesso non è nota. Perciò non è possibile usare algoritmo con RAG o il banchiere in programmi che possono cambiare durante l’esecuzione a seconda degli input provenienti dall’esterno, ovvero di programmi che avanzino la possibilità che un processo possa chiedere poche o tante risorse. Sono quindi algoritmi poco usati. Anche l’uso della prevenzione dinamica ha basso uso delle risorse. RAG (approfondimento). Il RAG è un modo grafico per poter rappresentare/descrivere le situzioni di stallo. Il RAG è un insieme di nodi e archi. I nodi posso collegarsi tra loro tramite l’uso degli archi. L’immagine sotto è un esempio di deadlock! I nodi (insieme V) sono costituiti da: cerchi = processi (CPU; I/O, memoria) rettangoli = risorse. Ogni risorsa ha un pallino rappresentante l’istanza: 2 pallini = 2 istanze della risorsa. Gli archi (insieme E) possono direzionarsi cosi: da processo a risorsa: vuol dire che il processo sta richiedendo una risorsa. da risorsa a processo: vuol dire che il processo detiene una risorsa. Dall’immagine sopra si ha che: V = {(P1,P2,P3), (R1,R2,R3,R4)} E = {(R1,P2), (P1,R1), (R2,P1),(R2,P2), (R3,P3),(P2,R3)} ma la relazione tra i nodi (la direzione degli archi), può cambiare in fase di richiesta-&amp;gt;acquisizione-&amp;gt;rilascio delle risorse. Stato sicuro e stato non-sicuro (approfondimento). Il sistema si trova in uno stato sicuro (safe) se le risorse sono assegnate ai processi senza che si verifichi il deadlock (viene garantita che non si verifichi la condizione di circula wait, una delle 4 condizioni da violare per evitare il deadlock). In parole povere è una sequenza di allocazione risorse che permette a tutti i processi di usare le risorse per poter terminare la loro esecuzione. Le risorse, che verranno assegnate con una certa sequenza, andranno a formare una sequenza sicura di esecuzione processi. Se non esite una sequenza sicura allora il sistema si trova in uno stato non sicuro (unsafe). Una sequenza di processi può vivere in uno stato non sicuro senza cadere in deadlock, ma potrebbe anche incontrare un deadlock senza preavviso. Definire una sequenza sicura o non sicura è compito degli algoritmi di prevenzione dinamica (algoritmo con RAG e algoritmo del banchiere) . Una sequenza di processi è una sequenza sicura quando ogni processo della sequenza può richiedere e ottenere una o più risorse e, una volta ottenute, terminare. Le risorse, che il processo può richiedere e ottenere, sono quelle disponibili (non assegnate a nessuno) più quelle del processo che, avendo terminato prima di lui l’esecuzione, ha liberato le risorse usate. Se un processo non trova le risorse libere, può rimanere in attesa e prendere le risorse quando disponibili, perchè in questo contesto prima o poi si libereranno dato che non esiste l’attesa circolare. Una sequenza safe (sicura) non porterà mai a deadlock perchè viene violata la condizione di attesa circolare (circular wait), che non si verificherà. Ricordiamo che si tratta di prevenzione dinamica in cui il SO conosce a priori il n.ro massimo di risorse che ogni processo userà durante la sua vita. Per cui quando si è in uno stato non-sicuro il SO non riesce ad impedire al processo di chiedere le risorse per raggiungere il massimo dichiarato. Questo comportamento potrebbe condurre al deadlock perchè ciò che accade nello stato non-sicuro dipende da come si comporta il processo stesso quando rilascia o richiede risorse. Non tutti gli stati unsafe (non-sicuri) portano a deaklock, ma da uno stato unsafe posso andare in deadlock. Rilevazione-ripristino: scovare il deadlock e ripristinare il sistema. Quando un SO non fa uso degli algoritmi di prevenzione vuol dire che non previene il deadlock e può incontrarlo in qualsiasi momento. Se il deadlock interferisce su parte del sistema, senza bloccarlo completamente, si può agire come segue rilevando il deadlock e successivamente ripristinaer il sistema: Rilevazione. Usare un algoritmo che sia in grado di rilevare il deadlock, esaminando il sistema. Rilevazione e ripristino tramite RAG (istanza singola di ciascun tipo di risorsa): funziona correttamente solo se tutte le risorse del sistema hanno una sola istanza (come nella prevenzione dinamica). Per individuare un deadlock si va ad analizzare una variante del RAG chiamato grafo di attesa che a differenza del RAG contiene solo i processi collegati tra loro dagli archi: non ci sono i nodi delle risorse. Il sistema mantiene costantemente aggiornato il grafo di attesa. Durante l’analisi è invocato periodicamente un algoritmo per cercare un ciclo all’interno del RAG. Un vantaggio di questo metodo è il non dover conoscere in anticipo richieste necessarie. Uno svantaggio è il costo elevato del recovery. Nell’immagine sotto: (a) RAG - (b) Grafo di attesa risorse Algoritmo di rilevazione (più istanze di ciascun tipo di risorsa): se vi è più di una istanza per risorsa, non è possibile usare l’algoritomo Rilevazione e ripristino tramite RAG, ma si usa l’algoritmo di rilevazione. Questi verifica tutte le possibili sequenze di assegnazione risorse per i processi che non hanno ancora terminato. Se a fine verifica si ha una sequenza safe non ci sarà deadlock. È simile all’algoritmo del banchiere. L’algoritmo di rilevazione si usa considerando la presunta frequenza con la quale un deadlock si verifica e il numero dei processi influenzati da un deadlock. Viene richiamato ad ogni richiesta risorsa e, come altrnativa meno dispensiosa, potrebbe essere richiamato ad intervalli di tempo oppure quando si hauna drastica riduzione dell’uso CPU dovuto ad un deadlock (che di norma rende inefficiente le prestazioni del sistema). Ripristino. Usare un algoritmo che in caso di deadlock, riporti il sistema ad uno stato precedente al deadlock. Terminazione dei processi (uccisione): è possibile terminare tutti i processi per interrompe il deadlock ma si perde il lavoro (magari di molti calcoli) già svolto dai processi ed inoltre se il processo prima del deadlock stava aggiornando un programma o un file, terminare vuol dire comprometterne l’uso. È possibile anche terminare un processo alla volta fin quando il deadlock viene interrotto, ma si genera overhead perchè ad ogni terminazione processo bisogna invocare l’algoritmo di rilevazione per vedere se ci sono altri processi che provocano deadlock. Prelazione delle risorse dai processi bloccati nel deadlock: è possibile sottrarre le risorse in successione a processi selezionati e darle ad altri processi in modo da interrompere il deadlock. Si selezionano perché è necessario capire come gestire il processo che subisce la prelazione, dal momento che perderebbe tutto il lavoro fatto risultando essere uno spreco di risorsa. Inoltre bisogna definire se salvare lo stato del processo da prelazionare (rollback), in modo da riprenderlo sucessivamente, o se terminare il processo e riavviarlo in seguito. Il rollback è efficace ma dispendioso in risorse. Per finire bisogna assicurare che le risorse non vengano sottratte sempre allo stesso processo.</summary></entry><entry><title type="html">Funzioni e memoria STACK</title><link href="https://www.hosthello.com/posts/funzioni-e-memoria-stack" rel="alternate" type="text/html" title="Funzioni e memoria STACK" /><published>2020-11-18T13:00:00+01:00</published><updated>2020-11-18T13:00:00+01:00</updated><id>https://www.hosthello.com/posts/funzioni-e-memoria-stack</id><content type="html" xml:base="https://www.hosthello.com/posts/funzioni-e-memoria-stack">&lt;p&gt;&lt;img src=&quot;https://images.unsplash.com/photo-1493946740644-2d8a1f1a6aff?ixlib=rb-1.2.1&amp;amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;amp;auto=format&amp;amp;fit=crop&amp;amp;w=1536&amp;amp;q=80&quot; alt=&quot;Funzioni e memoria stack&quot; title=&quot;Funzioni e memoria stack&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Analizziamo il codice sotto e arriveremo a capire come una funzione, che non rispetta alcuni accorgimenti, generi un output inaspettato.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;

void foo1(int xval) {
    int x;
    x = xval;
    
    // stampa l'indirizzo e il valore di x
    printf(&quot;Indirizzo di x: %p\n&quot;, &amp;amp;x);
    printf(&quot;   Valore di x: %i\n\n&quot;, x);
}

void foo2(int dummy) {
    int y;
    
    //stampa l'indirizzo e il valore di y 
    printf(&quot;Indirizzo di y: %p\n&quot;, &amp;amp;y);
    printf(&quot;   Valore di y: %i\n&quot;, y);
}

int main(void) {   // funzione principale
    foo1(7);
    foo2(11);
    
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Dopo aver compilato ed eseguito il programma, l’output prodotto sarà il seguente:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Indirizzo di x: 0x7ffc0c90bc6c
Valore di x: 7

Indirizzo di y: 0x7ffc0c90bc6c
Valore di y: 7
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Nota.&lt;/strong&gt; l’ &lt;code class=&quot;highlighter-rouge&quot;&gt;indirizzo di x&lt;/code&gt; e l’&lt;code class=&quot;highlighter-rouge&quot;&gt;indirizzo di y&lt;/code&gt; cambieranno ad ogni esecuzione.&lt;/p&gt;

&lt;h2 id=&quot;cosa-succede&quot;&gt;Cosa succede.&lt;/h2&gt;

&lt;p&gt;Generalemente, quando una funzione viene invocata, la memoria del calcolatore viene riservata per intero alla funzione. La memoria di cui si parla è lo &lt;a href=&quot;https://it.wikipedia.org/wiki/Pila_(informatica)&quot;&gt;STACK&lt;/a&gt;. Più precisamente, alla funzione, si riservano dei blocchi di memoria meglio conosciuti come “&lt;em&gt;slot di memoria&lt;/em&gt;”. Ogni slot avrà un proprio &lt;em&gt;indirizzo di memoria&lt;/em&gt; e una dimesione specifica. In ogni slot verrà inserito un dato. Il dato sarà datermianto in base a come viene dichiarato il &lt;em&gt;tipo di dato&lt;/em&gt; (es: intero, char, float o anche puntatore ecc…).&lt;/p&gt;

&lt;p&gt;Guardiamo il codice della funzione &lt;code class=&quot;highlighter-rouge&quot;&gt;foo1()&lt;/code&gt; per capirne il funzionamento:&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;foo1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;xval&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;xval&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    
    &lt;span class=&quot;c1&quot;&gt;// stampa l'indirizzo e il valore di x&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Indirizzo di x: %p&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;   Valore di x: %i&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Quando in &lt;code class=&quot;highlighter-rouge&quot;&gt;main()&lt;/code&gt; la funzione è invocata, lo stack è reso interamente a disposizione della funzione chiamante. Con &lt;code class=&quot;highlighter-rouge&quot;&gt;int x;&lt;/code&gt; si dichiara la variabile &lt;code class=&quot;highlighter-rouge&quot;&gt;x&lt;/code&gt; come intero e nello stack succede che alla variabile &lt;code class=&quot;highlighter-rouge&quot;&gt;x&lt;/code&gt; viene assegnato un indirizzo di memoria in modo da poter “localizzare” la variabile durante l’uso del programma (una sorta di indirizzo civico di un’abitazione). Con &lt;code class=&quot;highlighter-rouge&quot;&gt;x = xval;&lt;/code&gt;  si inizializza la variabile &lt;code class=&quot;highlighter-rouge&quot;&gt;x&lt;/code&gt; con il valore del “parametro formale” della funzione; in pratica si “riempie” il primo slot di memoria libero con un dato. Nel nostro caso l’inizializzazione della variabile fa si che nel primo slot di memoria disponibile sullo STACK viene inserito il valore del parametro formale &lt;code class=&quot;highlighter-rouge&quot;&gt;xval&lt;/code&gt; della funzione (in questo caso il valore è il numero 7 perchè nella funzione principale &lt;code class=&quot;highlighter-rouge&quot;&gt;main()&lt;/code&gt; si invoca &lt;code class=&quot;highlighter-rouge&quot;&gt;foo1(7)&lt;/code&gt;). Successivamente si esegue la stampa dell’indirizzo e poi del valore contenuto nella variabile &lt;code class=&quot;highlighter-rouge&quot;&gt;x&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&quot;quando-la-funzione-termina-la-memoria-viene-deallocata&quot;&gt;Quando la funzione termina la memoria viene deallocata.&lt;/h3&gt;

&lt;p&gt;Terminata la funzione la memoria dello STACK viene &lt;em&gt;deallocata&lt;/em&gt; (cioè resa nuovamente disponibile per altri usi; è un comportamento di default dello stack quando si usano le funzioni).&lt;/p&gt;

&lt;p&gt;Il valore 7 però non viene cancellato dallo slot di memoria, ma &lt;strong&gt;continua ad esistere&lt;/strong&gt; fin quando non verrà sovrascritto (nota che lo slot di memoria continua ad avere SEMPRE lo stesso indirizzo “fisico” di memoria). Il dato verrà sovrascritto solo quando (ad esempio) si &lt;strong&gt;inizializza&lt;/strong&gt; una nuova variabile di una qualsiasi altra funzione invocata.&lt;/p&gt;

&lt;p&gt;Ciò non accade quando si invoca la funzione &lt;code class=&quot;highlighter-rouge&quot;&gt;foo2()&lt;/code&gt; che dichiara, &lt;strong&gt;ma non inizializza&lt;/strong&gt;, la varibile &lt;code class=&quot;highlighter-rouge&quot;&gt;y&lt;/code&gt;. La &lt;em&gt;dichiarazione&lt;/em&gt; assegna alla variabile &lt;code class=&quot;highlighter-rouge&quot;&gt;y&lt;/code&gt; &lt;strong&gt;la prima locazione di memoria disponibile sullo stack&lt;/strong&gt;, in questo caso la stessa locazione di memoria usata precedentemente dalla variabile dichiarata come &lt;code class=&quot;highlighter-rouge&quot;&gt;int x&lt;/code&gt;.&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;foo2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dummy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    
    &lt;span class=&quot;c1&quot;&gt;//stampa l'indirizzo e il valore di y &lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Indirizzo di y: %p&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;   Valore di y: %i&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Alla locazione di memoria (indirizzo) ora assegnato alla variabile &lt;code class=&quot;highlighter-rouge&quot;&gt;int y&lt;/code&gt; esiste ancora il dato (sovrascrivibile) usato da &lt;code class=&quot;highlighter-rouge&quot;&gt;int x&lt;/code&gt;. Non inizializzare, o comunque non riempire la varibile &lt;code class=&quot;highlighter-rouge&quot;&gt;y&lt;/code&gt;, fa si che il dato presente nella locazione di memoria assegnata a &lt;code class=&quot;highlighter-rouge&quot;&gt;y&lt;/code&gt; non si sovrascriva!&lt;/p&gt;

&lt;p&gt;Quando si stampa, la funzione &lt;code class=&quot;highlighter-rouge&quot;&gt;printf(&quot;   Valore di y: %i\n&quot;, y);&lt;/code&gt; stampa il valore contenuto nella variabile &lt;code class=&quot;highlighter-rouge&quot;&gt;y&lt;/code&gt;. Essendo che la varibile &lt;code class=&quot;highlighter-rouge&quot;&gt;y&lt;/code&gt; risiede nello slot di memoria gia usato in precedenza, conterrà il dato inserito dalla funzione precedente (appunto perchè &lt;code class=&quot;highlighter-rouge&quot;&gt;y&lt;/code&gt; non è stata &lt;strong&gt;inizializzata&lt;/strong&gt;).&lt;/p&gt;

&lt;p&gt;Questo spiega il perchè l’output della funzione &lt;code class=&quot;highlighter-rouge&quot;&gt;foo2()&lt;/code&gt; generi sempre il valore 7 al posto del valore 11, come ci si aspetterebbe vedendo la funzione &lt;code class=&quot;highlighter-rouge&quot;&gt;foo2(11)&lt;/code&gt; nella funzione principale &lt;code class=&quot;highlighter-rouge&quot;&gt;main()&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Se la variabile &lt;code class=&quot;highlighter-rouge&quot;&gt;y&lt;/code&gt; fosse stata inizializza nel modo seguente &lt;code class=&quot;highlighter-rouge&quot;&gt;y = dummy&lt;/code&gt; l’output sarebbe stato 11.&lt;/p&gt;</content><author><name>Ivan Garrini</name></author><summary type="html"></summary></entry><entry><title type="html">Che cos’è il nucleo della rete</title><link href="https://www.hosthello.com/posts/cosa-e-il-nucleo-della-rete" rel="alternate" type="text/html" title="Che cos'è il nucleo della rete" /><published>2020-08-25T00:00:00+02:00</published><updated>2020-08-25T00:00:00+02:00</updated><id>https://www.hosthello.com/posts/cosa-e-il-nucleo-della-rete</id><content type="html" xml:base="https://www.hosthello.com/posts/cosa-e-il-nucleo-della-rete">&lt;p&gt;In &lt;a href=&quot;la-rete-di-accesso&quot; title=&quot;Articolo sulla rete di accesso&quot;&gt;precedenza&lt;/a&gt; si è trattata la parte &lt;em&gt;periferica&lt;/em&gt; della rete internet. Ora vediamo la parte interna denominata &lt;em&gt;nucleo&lt;/em&gt;: qui si hanno i dispositivi che permettono lo scambio dei messaggi tra vari host appartenenti alla stessa rete e o a &lt;em&gt;reti differenti&lt;/em&gt;.&lt;/p&gt;

&lt;h3 id=&quot;store-and-forward&quot;&gt;Store-and-forward&lt;/h3&gt;

&lt;p&gt;È stato accennato che i &lt;em&gt;commutatori di pacchetto&lt;/em&gt; (router e switch), insieme alla &lt;em&gt;rete di collegamento&lt;/em&gt;, sono parte integrante di internet. Questi sono i dispositivi del nucleo della rete. Router e switch sono &lt;strong&gt;commutatori di pacchetto&lt;/strong&gt; che usano la &lt;strong&gt;trasmissione store-and-forward&lt;/strong&gt; dove il commutatore &lt;strong&gt;deve ricevere tutto il pacchetto prima di trasmetterlo sul collegamento in uscita&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Router e switch, mentre ricevono un pacchetto, immagazzinano i suoi bit all’interno di un &lt;strong&gt;buffer&lt;/strong&gt; e quando sarà ricevuto tutto il pacchetto questi verrà trasmesso sul collegamento in uscita. Se il pacchetto non trova un buffer a disposizione perchè tutti pieni, viene scartato.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;Store-and-forward&lt;/strong&gt; 
Un commutatore di pacchetto (router o switch) deve ricevere l’intero pacchetto prima di poterlo trasmettere sul collegamento in uscita.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;I pacchetti vengono trasmessi su di un collegamento alla velocità del collegamento stesso. Il &lt;strong&gt;tempo di trasmissione&lt;/strong&gt; su un singolo collegamento dipende quindi dalla dimensione &lt;strong&gt;L&lt;/strong&gt; del pacchetto (in bit) e dalla velocità di trasmissione &lt;strong&gt;R&lt;/strong&gt; del collegamento (in bps): &lt;strong&gt;L/R&lt;/strong&gt;. Il tempo di trasmissione è il tempo richiesto per trasmettere tutti i bit sul collegamento.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Tempo di trasmissione = dimensione pacchetto/velocità collegamento = L/R&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Se il pacchetto per raggiungere la destinazione deve passare 2 collegamenti, il tempo di trasmissione sarà 2*L/R per ogni singolo pacchetto.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../img/store-and-forward.jpg&quot; alt=&quot;store-and-forward.jpg&quot; title=&quot;store-and-forward.jpg&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;NOTA.&lt;/strong&gt; nell’esempio precedente per semplicità vengono considerati SOLO i tempi di invio. Altri tempi influiranno sul reale tempo di trasmissione di un pacchetto.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;NOTA 2.&lt;/strong&gt; Il tempo di trasmissione viene considerato anche come &lt;strong&gt;ritardo di trasmissione&lt;/strong&gt; o &lt;strong&gt;ritardo store-and-forward&lt;/strong&gt;, perchè effettivamente L/R è il tempo che impiega il pacchetto durante il viaggio per arrivare a destinazione. In un percorso con N collegamenti si hanno N-1 Router. Nell’esempio precedente si hanno 2 collegamenti per cui router=1.&lt;/p&gt;

&lt;p&gt;Possiamo calcolare quindi il ritardo da PC a PC chiamato &lt;strong&gt;Ritardo end-to-end&lt;/strong&gt; (qui non sono considerati i ritardi di elaborazione e propagazione trattati più avanti):&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;R end-to-end = N(R/L)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Nell’esempio precedente il ritardo e-to-e è 2R/L ossia il tempo di trasmissione effettivo su due collegamenti.&lt;/p&gt;</content><author><name>Ivan</name></author><summary type="html">In precedenza si è trattata la parte periferica della rete internet. Ora vediamo la parte interna denominata nucleo: qui si hanno i dispositivi che permettono lo scambio dei messaggi tra vari host appartenenti alla stessa rete e o a reti differenti. Store-and-forward È stato accennato che i commutatori di pacchetto (router e switch), insieme alla rete di collegamento, sono parte integrante di internet. Questi sono i dispositivi del nucleo della rete. Router e switch sono commutatori di pacchetto che usano la trasmissione store-and-forward dove il commutatore deve ricevere tutto il pacchetto prima di trasmetterlo sul collegamento in uscita. Router e switch, mentre ricevono un pacchetto, immagazzinano i suoi bit all’interno di un buffer e quando sarà ricevuto tutto il pacchetto questi verrà trasmesso sul collegamento in uscita. Se il pacchetto non trova un buffer a disposizione perchè tutti pieni, viene scartato. Store-and-forward Un commutatore di pacchetto (router o switch) deve ricevere l’intero pacchetto prima di poterlo trasmettere sul collegamento in uscita. I pacchetti vengono trasmessi su di un collegamento alla velocità del collegamento stesso. Il tempo di trasmissione su un singolo collegamento dipende quindi dalla dimensione L del pacchetto (in bit) e dalla velocità di trasmissione R del collegamento (in bps): L/R. Il tempo di trasmissione è il tempo richiesto per trasmettere tutti i bit sul collegamento. Tempo di trasmissione = dimensione pacchetto/velocità collegamento = L/R Se il pacchetto per raggiungere la destinazione deve passare 2 collegamenti, il tempo di trasmissione sarà 2*L/R per ogni singolo pacchetto. NOTA. nell’esempio precedente per semplicità vengono considerati SOLO i tempi di invio. Altri tempi influiranno sul reale tempo di trasmissione di un pacchetto. NOTA 2. Il tempo di trasmissione viene considerato anche come ritardo di trasmissione o ritardo store-and-forward, perchè effettivamente L/R è il tempo che impiega il pacchetto durante il viaggio per arrivare a destinazione. In un percorso con N collegamenti si hanno N-1 Router. Nell’esempio precedente si hanno 2 collegamenti per cui router=1. Possiamo calcolare quindi il ritardo da PC a PC chiamato Ritardo end-to-end (qui non sono considerati i ritardi di elaborazione e propagazione trattati più avanti): R end-to-end = N(R/L) Nell’esempio precedente il ritardo e-to-e è 2R/L ossia il tempo di trasmissione effettivo su due collegamenti.</summary></entry><entry><title type="html">Come funziona un sistema operativo</title><link href="https://www.hosthello.com/posts/note-su-come-funziona-un-sistema-operativo" rel="alternate" type="text/html" title="Come funziona un sistema operativo" /><published>2020-07-20T00:00:00+02:00</published><updated>2020-07-20T00:00:00+02:00</updated><id>https://www.hosthello.com/posts/note-su-come-funziona-un-sistema-operativo</id><content type="html" xml:base="https://www.hosthello.com/posts/note-su-come-funziona-un-sistema-operativo">&lt;p&gt;Un programma è un &lt;strong&gt;insieme di istruzioni&lt;/strong&gt; che devono essere &lt;em&gt;eseguite&lt;/em&gt; per far si che il programma sia utile a qualcosa. Le istruzioni per diventare eseguibili devono diventare processi. I processi li esegue la CPU!&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Il programma non è un processo, ma un’entità passiva contenente istruzioni che non hanno “vita”. Un processo è un’entità attiva che ha “vita”. Infatti un processo si genera, evolve, termina, produce figli, coopera con gli altri processi ecc… Il programma no.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Un programma diventa processo quando il suo file eseguibile viene caricato in &lt;strong&gt;memoria principale&lt;/strong&gt;. Questo è un modo iniziale di generare processi.&lt;/p&gt;

&lt;p&gt;Quando è in memoria principale, il processo invierà le istruzioni da eseguire (e i dati su cui lavorare) alla CPU. Questa memoria è detta anche &lt;strong&gt;memoria di lavoro&lt;/strong&gt; o RAM.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Se il programma è un &lt;strong&gt;insieme di istruzioni&lt;/strong&gt;, il processo è un’&lt;strong&gt;istanza&lt;/strong&gt; del programma. Per istanza si intende l’esecuzione di un’&lt;strong&gt;unità&lt;/strong&gt;/parte  del programma. Il programma può essere quindi formato da uno o più unità, ossia da uno o più processi.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Se due processi sono associati allo stesso programma, sono comunque due sequenze d’esecuzione diverse.&lt;/p&gt;

&lt;h2 id=&quot;stati-processo&quot;&gt;Stati processo&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;../img/transazioni-stati-processi.png&quot; alt=&quot;foo&quot; title=&quot;Transazioni stati processi&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Quando un processo entra in memoria RAM (transazione 0) è stato schedulato dallo &lt;strong&gt;scheduler a lungo temrine&lt;/strong&gt; e si trova in uno &lt;strong&gt;stato di pronto&lt;/strong&gt;. Vuol dire che è pronto per l’esecuzione, ma ancora non ha a disposizione la CPU (perchè non non gli è stata assegnata) per eseguire le istruzioni. In questo stato, il sistema operativo fa uso dello &lt;strong&gt;scheduler a breve terminare&lt;/strong&gt; per determinare a quale processo assegnare la CPU. Lo scheduler usa delle politiche specifiche per decidere a quale processo asseganre la CPU.&lt;/p&gt;

&lt;blockquote style=&quot;border: solid 1px #00b8d4; border-left: 5px solid #00b8d4; background: #00b8d40a; padding: 20px; border-radius: 5px; font-size: 14px;&quot;&gt;
  &lt;p&gt;È lo &lt;strong&gt;scheduler a breve termine&lt;/strong&gt; che seleziona il processo dalla &lt;strong&gt;coda dei processi pronti&lt;/strong&gt; e lo passa alla CPU.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote style=&quot;border: solid 1px #00b8d4; border-left: 5px solid #00b8d4; background: #00b8d40a; padding: 20px; border-radius: 5px; font-size: 14px;&quot;&gt;
  &lt;p&gt;&lt;strong&gt;Operazione di Dispatch&lt;/strong&gt;: sono operazioni che si eseguono quando il processo passa dalla coda dei processi (stato di pronto) ed assegnato alla CPU (stato di esecuzione). Le operazioni sono:&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;cambio contesto: detto &lt;em&gt;context-switch&lt;/em&gt;, viene salvato il PCB del processo che lascia la CPU e sulla CPU viene caricato il PCB del processo che andrà in esecuzione.&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;#nonprocess-kernel-kernel-separato&quot;&gt;Passaggio alla modalità utente&lt;/a&gt;: quando il processo è nella &lt;strong&gt;coda dei processi&lt;/strong&gt;, il sistema è in &lt;strong&gt;kernel-mode&lt;/strong&gt; (esecuzione del codice del SO). Quando il processo è assegnato alla CPU il sistema è passato in modalità &lt;strong&gt;user-mode&lt;/strong&gt; (esecuzione del codice utente).&lt;/li&gt;
    &lt;li&gt;si esegure l’istruzione del processo entrato in CPU.&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;i-casi-dello-stato-di-esecuzione&quot;&gt;I casi dello stato di esecuzione&lt;/h3&gt;

&lt;p&gt;Quando lo scheduler sceglie il processo da mandare in esecuzione (transazione 1), il processo passa nello &lt;strong&gt;stato di esecuzione&lt;/strong&gt; e la CPU è assegnata al processo. Il processo, tramite le istruzioni per cui è stato programmato, userà la CPU per compiere calcoli.&lt;/p&gt;

&lt;p&gt;Un &lt;strong&gt;processo in esecuzione&lt;/strong&gt; può ritrovarsi in uno dei seguenti casi:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;può &lt;strong&gt;sdoppiarsi&lt;/strong&gt; diventanto un processo padre che ha creato un processo figlio&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;può &lt;strong&gt;richiedere o subire interventi di I/O&lt;/strong&gt; come la richiesta di input da tastiera o quando si muove il mouse&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;può subire un’&lt;strong&gt;interrupt&lt;/strong&gt; ossia gli viene tolta la CPU in modo forzato&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;può &lt;strong&gt;terminare&lt;/strong&gt; la sua esecuzione&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;sdoppiamento-e-richieste-di-io&quot;&gt;Sdoppiamento e richieste di I/O&lt;/h4&gt;

&lt;p&gt;Quando si verificano il primo e secondo caso il processo passa in uno &lt;strong&gt;stato di attesa&lt;/strong&gt; (transazione 3). Vediamo gli esempi seguenti:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;quando un processo crea un figlio, deve attendere che questo &lt;em&gt;termini&lt;/em&gt; la sua esecuzione. Il processo principale (il padre) passa nello &lt;em&gt;stato di attesa&lt;/em&gt; mentre il figlio continua la sua esistenza nello &lt;em&gt;stato di esecuzione&lt;/em&gt; usando la CPU.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;quando un processo deve eseguire un’istruzione di I/O come ad esempio ricevere una carattere da tastiera, l’attesa nell’aspettare che l’utente prema il tasto la svolge appunto nello &lt;em&gt;stato di attesa&lt;/em&gt; (transazione 3).&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;Ricordiamo che parliamo di processori velocissimi che svolgono operazioni alla velocità dei millesimi di secondo, per cui l’intervento dell’uomo (anche per premere un solo tasto) è un tempo molto lungo se considerato dal punto di vista del processore che compie operazioni in tempi brevissimi.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Continuando a considerare gli esempi precedenti, (es.1) il padre esce dallo &lt;em&gt;stato di attesa&lt;/em&gt; quando il processo figlio ha terminato la sua esecuzione, oppure (es.2) il processo esce dallo &lt;em&gt;stato di attesa&lt;/em&gt; quando ha ricevuto l’input che aveva richiesto. In entrambi gli esempi si ritorna  nello &lt;em&gt;stato di pronto&lt;/em&gt; (transazione 4) dove il processo si “accoda” agli altri processi presenti nella coda dei “processi pronti” per poi passare ancora nello &lt;em&gt;stato di esecuzione&lt;/em&gt; (transazione 1). Essendo che il processo si ritrova nella coda dei &lt;em&gt;processi pronti&lt;/em&gt; vuol dire che deve ancora eseguire delle istruzioni prima di terminare.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Nota&lt;/strong&gt;: in base al tipo di processo lo &lt;em&gt;stato di attesa&lt;/em&gt; contiene una serie di code di attesa chiamate &lt;strong&gt;code di dispositivo&lt;/strong&gt;.&lt;/p&gt;

&lt;div style=&quot;border:solid 1px #ddd; padding: 3%; padding-top: 1.5%; padding-bottom: 1.5%;&quot;&gt;

  &lt;h4 id=&quot;multiprogrammazione&quot;&gt;Multiprogrammazione&lt;/h4&gt;

  &lt;p&gt;La multiprogrammazione permette di aumentare la percentuale d’uso della CPU perchè &lt;strong&gt;prevede la possibilità di mantenere in memoria più processi contemporaneamente&lt;/strong&gt; in modo da essere schedulati ed assegnati alla CPU.&lt;/p&gt;

  &lt;p&gt;Quando si dice che un programma per essere eseguito deve essere prima caricato in memoria centrale (RAM) è vero in parte. Infatti non viene caricato totalemente in  RAM, ma solo una parte ossia solo i processi ritenuti utili ai fini del funzionamento del programma. L’altra parte dei processi rimangono su una apposita area di memoria (pool dei processi o jobpool) del disco primario e prelevati quando necessari.&lt;/p&gt;

  &lt;p&gt;Lo &lt;em&gt;stato di attesa&lt;/em&gt; è un esempio di cosa si intende per multiprogrammazione. Infatti quando un processo va in attesa, grazie alla multiprogrammazione il SO può prendere un altro processo in &lt;em&gt;stato di pronto&lt;/em&gt; e mandarlo in esecuzione. In questo modo la CPU non rimane mai inattiva.&lt;/p&gt;

  &lt;p&gt;Senza la multiprogrammazione si sarebbe verificato che il processo in &lt;em&gt;stato di attesa&lt;/em&gt; avrebbe bloccato gli altri processi pronti per andare in esecuzione. Questo perchè i processi in &lt;em&gt;stato di pronto&lt;/em&gt; avrebbero dovuto aspettare che il processo in attesa terminasse il proprio evento (esempio se vi era una richiesta di I/O o un’attesa di terminazione di un figlio). In questo modo la CPU sarebbe rimasta inattiva fin quando l’evento (che aveva portato il processo in attesa) non fosse terminato.&lt;/p&gt;

  &lt;p&gt;La tecnica della multiprogrammazione appena descritta è su un sistema &lt;strong&gt;monoprocessore&lt;/strong&gt; e permette di &lt;em&gt;mantenere la CPU occupata il più possibile&lt;/em&gt;. Ciò fa credere all’utente che più processi siano in esecuzione contemporaneamente (multitasking), quando invece sono sempre processati &lt;em&gt;sequenzialmente&lt;/em&gt;. La vera potenza del multitasking è da trovare nell’algoritmo di scheduling usato.&lt;/p&gt;

  &lt;p&gt;Nei sistemi &lt;em&gt;multiprocessore&lt;/em&gt; è possibile lo scenario precedente ma in più è possibile anche l’esecuzione contemporanea di processi.&lt;/p&gt;
&lt;/div&gt;

&lt;h4 id=&quot;interrupt&quot;&gt;Interrupt&lt;/h4&gt;

&lt;p&gt;Per quanto riguarda il terzo caso, il processo può subire un &lt;em&gt;interrupt&lt;/em&gt; dove la CPU gli viene tolta in modo forzato. In questo caso il processo può passare nello &lt;em&gt;stato di pronto&lt;/em&gt; (transazione 2) oppure passare nell &lt;em&gt;stato di attesa&lt;/em&gt; (transazione 3). Nel primo caso torna quindi in memoria RAM e inserito nella coda dei processi pronti. Nel secondo viene inserito in determiante code di attesa.&lt;/p&gt;

&lt;p&gt;I processi di un programma sono di due tipi: &lt;strong&gt;CPU bound&lt;/strong&gt; e &lt;strong&gt;I/O bound&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;I primi dipendono fortemente dalla disponibilità della CPU e sono quei processi che svolgono elevate attività di elaborazione dati. Questi, se non forzati, non rilasciano mai la CPU fin che non finiscono la loro esecuzione e, se forzati a rilasciare la CPU, non vanno mai in &lt;em&gt;stato di attesa&lt;/em&gt; ma passano in &lt;em&gt;stato di pronto&lt;/em&gt; (transazione 2) accodandosi ai processi pronti per l’esecuzione.&lt;/p&gt;

&lt;p&gt;I secondi dipendono principalmente dall’I/O. Possono rilasciare la CPU in modo autonomo per eseguire attività di I/O o possono comunque essere forzati. In etrambi i casi vanno in &lt;em&gt;stato di attesa&lt;/em&gt; (transazione 3).&lt;/p&gt;

&lt;p&gt;Che sia &lt;em&gt;CPU bound&lt;/em&gt; o &lt;em&gt;I/O bound&lt;/em&gt; se il processo rimane in esecuzione per più di un determinato “quanto” di tempo avverà un interrupt, anche se il processo è un figlio.&lt;/p&gt;

&lt;div style=&quot;border:solid 1px #ddd; padding: 3%; padding-top: 1.5%; padding-bottom: 1.5%;&quot;&gt;

  &lt;h5 id=&quot;time-sharing-o-multitasking&quot;&gt;Time-sharing (o multitasking)&lt;/h5&gt;

  &lt;p&gt;L’interrupt è un segnale di rilascio forzato della CPU gestito dal SO. Può essere di tipo software o hardware.&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;
      &lt;p&gt;Il primo (tipo software) avviene nei calcolatori con più di un processore (multicore o più CPU) dove è il SO ad intervenire inviando un segnale di interruzione obbligando il processo a non usare più la CPU.&lt;/p&gt;
    &lt;/li&gt;
    &lt;li&gt;
      &lt;p&gt;Il secondo (tipo hardware) avviene nei vecchi calcolatori a singolo processore (una sola CPU): ora, essendo che sia il SO che un processo per eseguire il proprio codice devono avere a disposizione la CPU, in un ambiente a singolo processore se un processo è in esecuzione si verificherà che il SO (non essendo in esecuzione perchè la CPU è gia in uso) non può intervenire per eseguire il codice che permettere di interrompere l’uso della CPU. Per cui prima che la CPU venga assegnata ad un processo, il SO attiva un dispositivo hardware che interrompe automaticamente l’esecuzione del codice del processo dopo un determinato periodo di tempo.&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ul&gt;

  &lt;p&gt;Ci sono vari tipi di interrupt, usati per scopi differenti da quello menzionato sopra. Ma questo tipo di interrupt è tipico dell’ambiente &lt;strong&gt;time-sharing (multitasking)&lt;/strong&gt; dove l’interrupt viene eseguito dopo un determianto quanto di tempo. Ciò permette di eseguire (dare la CPU) in modo “sequenziale” i processi (uno dopo l’altro) . All’occhio umano sembra che i programmi lavorino simultaneamente e che i processi si sovrappongano, ma ciò è solo un’illusione data dall’altissima velocità con cui i processi si scambiano l’uso della CPU.&lt;/p&gt;

&lt;/div&gt;

&lt;h4 id=&quot;terminazione&quot;&gt;Terminazione&lt;/h4&gt;

&lt;p&gt;Nel quarto caso, se il processo termina esce dallo &lt;em&gt;stato di esecuzione&lt;/em&gt; (transazione 5) e tutte le risorse a lui assegnate vengono liberate. Un processo che ha terminato l’esecuzione è un processoche ha eseguito tutte le istruzioni per cui era stato programmato.&lt;/p&gt;

&lt;h2 id=&quot;thread&quot;&gt;Thread&lt;/h2&gt;

&lt;p&gt;Un processo a singolo thread è un programma che esegue un unico percorso di esecuzione dove l’esecuzione delle programma stesso avvine seguendo una &lt;em&gt;singola sequenza di istruzioni&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Nei sistemi multicore i thread possono essere eseguiti in parallelo cosi da avere un processo composto da più thread (detto proceso multi-thread) dove ogni thread ha un proprio percorso di esecuzione differente dagli altri. In questo modo un processo può svolgere più compiti alla volta.&lt;/p&gt;

&lt;h2 id=&quot;kernel-o-nucleo&quot;&gt;Kernel o nucleo&lt;/h2&gt;

&lt;p&gt;Le risorse principali gestite dal SO sono la memoria, i controller di I/O e il processore/i.Un aporzione di sistema operativo si trova nella memoria principale in cui troviamo il &lt;strong&gt;kernel&lt;/strong&gt;. Il kernel contiene le funzioni più usate di frequente dal sistema operativo e in specifici archi di tempo altre porzioni di SO. La restante parte della memoria principale contiene i dati utente e programmi.&lt;/p&gt;

&lt;p&gt;Il SO decide quando un dispositivo I/O deve essere usato da un programma in esecuzione controllandone l’accesso e l’uso dei file. Il processore stesso è una risorsa, quindi il SO deve determinare quante volte un processore debba essere impiegato per l’esecuzione di un determinato programma utente. Se il sistema è multi-processore, questa decisione viene esetesa a tutti i processori.&lt;/p&gt;

&lt;h3 id=&quot;nonprocess-kernel-kernel-separato&quot;&gt;Nonprocess kernel (kernel separato)&lt;/h3&gt;

&lt;p&gt;Il kernel del SO è eseguito al di fuori di ogni processo. Con questo approccio se un processo in esecuzione è interroto, il PCB del processo viene salvato e il kernel riprende il controllo dell’intero sistema. Avendo il SO una sua partizione di memoria dedicata, può controllare le procedure di chiamata e come queste vendono eseguite. Può eseguire qualsiasi funzione e ripristinare i processi utente interrotti. Si occupa inoltre di gestire lo scheduling e il “dispatch” dei processi.&lt;/p&gt;

&lt;p&gt;Il concetto chiave è che &lt;strong&gt;il processo è un concetto applicabile solo al al programma utente&lt;/strong&gt;. Il processo non ha interazione “voluta” con il SO.&lt;/p&gt;

&lt;h3 id=&quot;kernel-eseguito-con-i-processi-utente&quot;&gt;Kernel eseguito con i processi utente&lt;/h3&gt;

&lt;p&gt;Tutte le funzioni del SO sono eseguite virtualemente e in modo indipendente con il processo utente. In pratica il SO è una collezione di routines. Il processo ha un suo ambiente (chiamato &lt;em&gt;immagine&lt;/em&gt;) di esecuzione dove l’utente può richiamare ed eseguire le routines del SO. Il SO può arrivare a gestire &lt;code class=&quot;highlighter-rouge&quot;&gt;n&lt;/code&gt; immagini. Quindi le immagini saranno formate dai componenti standard di un processo (PCB, user Stack, Heap, sezione dati ecc..) e dalle routine del SO utili al processo.&lt;/p&gt;

&lt;p&gt;Se un processo in esecuzione subisce interruzioni o trap (momento in cui il SO deve effettuare delle azioni), avviene il &lt;strong&gt;mode switch&lt;/strong&gt;. In base alle circostanze il mode-switch cambia l’attività del SO da &lt;em&gt;user-mode&lt;/em&gt; (esecuzione del codice utente) a &lt;em&gt;kernel-mode&lt;/em&gt; (esecuzione del codice del sistema operativo) e viceversa. Nota: il &lt;em&gt;mode-switch&lt;/em&gt; è l’alternativa leggera al &lt;strong&gt;&lt;em&gt;context-swicth&lt;/em&gt;&lt;/strong&gt; (situzione in cui il processo lascia la CPU in uso e il SO ne salva il PCB -&amp;gt; un PCB di un processo pronto viene caricato e il SO assegna la CPU a tale processo). Il processo va quindi in uno stato di &lt;strong&gt;nonrunning&lt;/strong&gt; in modo da permettere al SO di operare (ed usare la CPU). Quando il SO termina le sue attività può decidere se eseguire il &lt;em&gt;mode-switch&lt;/em&gt; (passando da kernel-mode a user-mode) in modo da riattivare il processo in stato di &lt;em&gt;nonrunning&lt;/em&gt; o eseguire il &lt;em&gt;context-switch&lt;/em&gt; in modo da far subentrare un nuovo processo.&lt;/p&gt;

&lt;h3 id=&quot;kernel-come-processo&quot;&gt;Kernel come processo&lt;/h3&gt;

&lt;p&gt;Come per il precedente, il software del kernel è eseguito in &lt;em&gt;kernel-mode&lt;/em&gt; e quello utente in &lt;em&gt;user-mode&lt;/em&gt; ma invece di avere le funzioni del SO integrate con il processo utente, le funzioni kernel sono organizzate come processi separati. Rimane sempre l’alternativa &lt;em&gt;context-switch&lt;/em&gt; in caso non si usi il &lt;em&gt;mode-switch&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Questo modello incoraggia un uso modulare del SO. Ha il vantaggio di essere utile in ambienti multiproessore dove ogni i processi del SO possono essere eseguiti su processori dedicati, migliorando le performance.&lt;/p&gt;

&lt;h2 id=&quot;scheduling&quot;&gt;Scheduling&lt;/h2&gt;

&lt;p&gt;Lo scheduling è l’attività svolta dal SO per aumentare l’uso della CPU, in mdo che non resti mai inattiva. È condizionato dal tipo di elaborazione da fare, CPU bound o I/O bound. Nel primo si verificano sequenze più lunghe di &lt;em&gt;operazioni svolte dalla CPU (CPU burst)&lt;/em&gt; mentre nel secondo le &lt;em&gt;CPU burst&lt;/em&gt; sono più brevi.&lt;/p&gt;

&lt;p&gt;Ci sono due tipi di scheduler e quello più importante e usato e lo &lt;strong&gt;scheduler della CPU&lt;/strong&gt; (o a breve termine). Questi prende il processo a cui assegnare la CPU dalla &lt;em&gt;coda dei processi pronti&lt;/em&gt;. Questa coda non è necessariamente FIFO, ma può essere una &lt;em&gt;coda con priorità&lt;/em&gt; o anche una &lt;em&gt;lista concatenata&lt;/em&gt;. Nella coda dei processi pronti gli elementi sono presenti i PCB del processo (e non l’intero processo).&lt;/p&gt;

&lt;h3 id=&quot;tipi-di-scheduling&quot;&gt;Tipi di scheduling&lt;/h3&gt;

&lt;p&gt;Se ne hanno 2 tipi:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;senza prelazione&lt;/strong&gt; dove la CPU rimane in uso al processo fino alla sua fine esecuzione o passaggio in stato attesa. È il tipo di scheduling presente nei SO prima del 1995 e spesso è l’alternativa migliore su determiate piattaforne odierne.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;con prelazione&lt;/strong&gt; (o cooperativo) dove la CPU viene forzatamente tolta al processo ed in uso sui SO dagli anni 1995 in poi. Per attuare la forzatura si usano ad es. i timer che danno luogo agli ambienti &lt;em&gt;time-sharing&lt;/em&gt; dove il processo lascia la CPU dopo un quanto di tempo. Questo tipo di schedulign porta a &lt;strong&gt;race condition&lt;/strong&gt; ossia quando un &lt;em&gt;dato&lt;/em&gt; condiviso tra processi è modificato da più parti alterandone il significato per il processo che lo riusa trovandolo incoerente da quando lo aveva lasciato. A tale scopo nasce la necessità si usare sistemi di sincronizzazione per l’&lt;strong&gt;accesso ai dati condivisi&lt;/strong&gt;.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;semafori&quot;&gt;Semafori&lt;/h2&gt;

&lt;p&gt;I semafori a &lt;strong&gt;valori binari&lt;/strong&gt; vengono utilizzati per la &lt;strong&gt;mutua esclusione&lt;/strong&gt; ossia un processo alla volta può accedere alla sezione critica.&lt;/p&gt;

&lt;p&gt;I semafori a &lt;strong&gt;valori interi&lt;/strong&gt; trovano applicazione nel controllo dell’accesso ad una data risorsa presente in un numero &lt;strong&gt;&lt;em&gt;finito&lt;/em&gt;&lt;/strong&gt; di esemplari. Il semaforo è inizialmente impostato al numero di risorse &lt;em&gt;disponibili&lt;/em&gt;.&lt;/p&gt;</content><author><name>Ivan</name></author><summary type="html">Un programma è un insieme di istruzioni che devono essere eseguite per far si che il programma sia utile a qualcosa. Le istruzioni per diventare eseguibili devono diventare processi. I processi li esegue la CPU! Il programma non è un processo, ma un’entità passiva contenente istruzioni che non hanno “vita”. Un processo è un’entità attiva che ha “vita”. Infatti un processo si genera, evolve, termina, produce figli, coopera con gli altri processi ecc… Il programma no. Un programma diventa processo quando il suo file eseguibile viene caricato in memoria principale. Questo è un modo iniziale di generare processi. Quando è in memoria principale, il processo invierà le istruzioni da eseguire (e i dati su cui lavorare) alla CPU. Questa memoria è detta anche memoria di lavoro o RAM. Se il programma è un insieme di istruzioni, il processo è un’istanza del programma. Per istanza si intende l’esecuzione di un’unità/parte del programma. Il programma può essere quindi formato da uno o più unità, ossia da uno o più processi. Se due processi sono associati allo stesso programma, sono comunque due sequenze d’esecuzione diverse. Stati processo Quando un processo entra in memoria RAM (transazione 0) è stato schedulato dallo scheduler a lungo temrine e si trova in uno stato di pronto. Vuol dire che è pronto per l’esecuzione, ma ancora non ha a disposizione la CPU (perchè non non gli è stata assegnata) per eseguire le istruzioni. In questo stato, il sistema operativo fa uso dello scheduler a breve terminare per determinare a quale processo assegnare la CPU. Lo scheduler usa delle politiche specifiche per decidere a quale processo asseganre la CPU. È lo scheduler a breve termine che seleziona il processo dalla coda dei processi pronti e lo passa alla CPU. Operazione di Dispatch: sono operazioni che si eseguono quando il processo passa dalla coda dei processi (stato di pronto) ed assegnato alla CPU (stato di esecuzione). Le operazioni sono: cambio contesto: detto context-switch, viene salvato il PCB del processo che lascia la CPU e sulla CPU viene caricato il PCB del processo che andrà in esecuzione. Passaggio alla modalità utente: quando il processo è nella coda dei processi, il sistema è in kernel-mode (esecuzione del codice del SO). Quando il processo è assegnato alla CPU il sistema è passato in modalità user-mode (esecuzione del codice utente). si esegure l’istruzione del processo entrato in CPU. I casi dello stato di esecuzione Quando lo scheduler sceglie il processo da mandare in esecuzione (transazione 1), il processo passa nello stato di esecuzione e la CPU è assegnata al processo. Il processo, tramite le istruzioni per cui è stato programmato, userà la CPU per compiere calcoli. Un processo in esecuzione può ritrovarsi in uno dei seguenti casi: può sdoppiarsi diventanto un processo padre che ha creato un processo figlio può richiedere o subire interventi di I/O come la richiesta di input da tastiera o quando si muove il mouse può subire un’interrupt ossia gli viene tolta la CPU in modo forzato può terminare la sua esecuzione Sdoppiamento e richieste di I/O Quando si verificano il primo e secondo caso il processo passa in uno stato di attesa (transazione 3). Vediamo gli esempi seguenti: quando un processo crea un figlio, deve attendere che questo termini la sua esecuzione. Il processo principale (il padre) passa nello stato di attesa mentre il figlio continua la sua esistenza nello stato di esecuzione usando la CPU. quando un processo deve eseguire un’istruzione di I/O come ad esempio ricevere una carattere da tastiera, l’attesa nell’aspettare che l’utente prema il tasto la svolge appunto nello stato di attesa (transazione 3). Ricordiamo che parliamo di processori velocissimi che svolgono operazioni alla velocità dei millesimi di secondo, per cui l’intervento dell’uomo (anche per premere un solo tasto) è un tempo molto lungo se considerato dal punto di vista del processore che compie operazioni in tempi brevissimi. Continuando a considerare gli esempi precedenti, (es.1) il padre esce dallo stato di attesa quando il processo figlio ha terminato la sua esecuzione, oppure (es.2) il processo esce dallo stato di attesa quando ha ricevuto l’input che aveva richiesto. In entrambi gli esempi si ritorna nello stato di pronto (transazione 4) dove il processo si “accoda” agli altri processi presenti nella coda dei “processi pronti” per poi passare ancora nello stato di esecuzione (transazione 1). Essendo che il processo si ritrova nella coda dei processi pronti vuol dire che deve ancora eseguire delle istruzioni prima di terminare. Nota: in base al tipo di processo lo stato di attesa contiene una serie di code di attesa chiamate code di dispositivo. Multiprogrammazione La multiprogrammazione permette di aumentare la percentuale d’uso della CPU perchè prevede la possibilità di mantenere in memoria più processi contemporaneamente in modo da essere schedulati ed assegnati alla CPU. Quando si dice che un programma per essere eseguito deve essere prima caricato in memoria centrale (RAM) è vero in parte. Infatti non viene caricato totalemente in RAM, ma solo una parte ossia solo i processi ritenuti utili ai fini del funzionamento del programma. L’altra parte dei processi rimangono su una apposita area di memoria (pool dei processi o jobpool) del disco primario e prelevati quando necessari. Lo stato di attesa è un esempio di cosa si intende per multiprogrammazione. Infatti quando un processo va in attesa, grazie alla multiprogrammazione il SO può prendere un altro processo in stato di pronto e mandarlo in esecuzione. In questo modo la CPU non rimane mai inattiva. Senza la multiprogrammazione si sarebbe verificato che il processo in stato di attesa avrebbe bloccato gli altri processi pronti per andare in esecuzione. Questo perchè i processi in stato di pronto avrebbero dovuto aspettare che il processo in attesa terminasse il proprio evento (esempio se vi era una richiesta di I/O o un’attesa di terminazione di un figlio). In questo modo la CPU sarebbe rimasta inattiva fin quando l’evento (che aveva portato il processo in attesa) non fosse terminato. La tecnica della multiprogrammazione appena descritta è su un sistema monoprocessore e permette di mantenere la CPU occupata il più possibile. Ciò fa credere all’utente che più processi siano in esecuzione contemporaneamente (multitasking), quando invece sono sempre processati sequenzialmente. La vera potenza del multitasking è da trovare nell’algoritmo di scheduling usato. Nei sistemi multiprocessore è possibile lo scenario precedente ma in più è possibile anche l’esecuzione contemporanea di processi. Interrupt Per quanto riguarda il terzo caso, il processo può subire un interrupt dove la CPU gli viene tolta in modo forzato. In questo caso il processo può passare nello stato di pronto (transazione 2) oppure passare nell stato di attesa (transazione 3). Nel primo caso torna quindi in memoria RAM e inserito nella coda dei processi pronti. Nel secondo viene inserito in determiante code di attesa. I processi di un programma sono di due tipi: CPU bound e I/O bound. I primi dipendono fortemente dalla disponibilità della CPU e sono quei processi che svolgono elevate attività di elaborazione dati. Questi, se non forzati, non rilasciano mai la CPU fin che non finiscono la loro esecuzione e, se forzati a rilasciare la CPU, non vanno mai in stato di attesa ma passano in stato di pronto (transazione 2) accodandosi ai processi pronti per l’esecuzione. I secondi dipendono principalmente dall’I/O. Possono rilasciare la CPU in modo autonomo per eseguire attività di I/O o possono comunque essere forzati. In etrambi i casi vanno in stato di attesa (transazione 3). Che sia CPU bound o I/O bound se il processo rimane in esecuzione per più di un determinato “quanto” di tempo avverà un interrupt, anche se il processo è un figlio. Time-sharing (o multitasking) L’interrupt è un segnale di rilascio forzato della CPU gestito dal SO. Può essere di tipo software o hardware. Il primo (tipo software) avviene nei calcolatori con più di un processore (multicore o più CPU) dove è il SO ad intervenire inviando un segnale di interruzione obbligando il processo a non usare più la CPU. Il secondo (tipo hardware) avviene nei vecchi calcolatori a singolo processore (una sola CPU): ora, essendo che sia il SO che un processo per eseguire il proprio codice devono avere a disposizione la CPU, in un ambiente a singolo processore se un processo è in esecuzione si verificherà che il SO (non essendo in esecuzione perchè la CPU è gia in uso) non può intervenire per eseguire il codice che permettere di interrompere l’uso della CPU. Per cui prima che la CPU venga assegnata ad un processo, il SO attiva un dispositivo hardware che interrompe automaticamente l’esecuzione del codice del processo dopo un determinato periodo di tempo. Ci sono vari tipi di interrupt, usati per scopi differenti da quello menzionato sopra. Ma questo tipo di interrupt è tipico dell’ambiente time-sharing (multitasking) dove l’interrupt viene eseguito dopo un determianto quanto di tempo. Ciò permette di eseguire (dare la CPU) in modo “sequenziale” i processi (uno dopo l’altro) . All’occhio umano sembra che i programmi lavorino simultaneamente e che i processi si sovrappongano, ma ciò è solo un’illusione data dall’altissima velocità con cui i processi si scambiano l’uso della CPU. Terminazione Nel quarto caso, se il processo termina esce dallo stato di esecuzione (transazione 5) e tutte le risorse a lui assegnate vengono liberate. Un processo che ha terminato l’esecuzione è un processoche ha eseguito tutte le istruzioni per cui era stato programmato. Thread Un processo a singolo thread è un programma che esegue un unico percorso di esecuzione dove l’esecuzione delle programma stesso avvine seguendo una singola sequenza di istruzioni. Nei sistemi multicore i thread possono essere eseguiti in parallelo cosi da avere un processo composto da più thread (detto proceso multi-thread) dove ogni thread ha un proprio percorso di esecuzione differente dagli altri. In questo modo un processo può svolgere più compiti alla volta. Kernel o nucleo Le risorse principali gestite dal SO sono la memoria, i controller di I/O e il processore/i.Un aporzione di sistema operativo si trova nella memoria principale in cui troviamo il kernel. Il kernel contiene le funzioni più usate di frequente dal sistema operativo e in specifici archi di tempo altre porzioni di SO. La restante parte della memoria principale contiene i dati utente e programmi. Il SO decide quando un dispositivo I/O deve essere usato da un programma in esecuzione controllandone l’accesso e l’uso dei file. Il processore stesso è una risorsa, quindi il SO deve determinare quante volte un processore debba essere impiegato per l’esecuzione di un determinato programma utente. Se il sistema è multi-processore, questa decisione viene esetesa a tutti i processori. Nonprocess kernel (kernel separato) Il kernel del SO è eseguito al di fuori di ogni processo. Con questo approccio se un processo in esecuzione è interroto, il PCB del processo viene salvato e il kernel riprende il controllo dell’intero sistema. Avendo il SO una sua partizione di memoria dedicata, può controllare le procedure di chiamata e come queste vendono eseguite. Può eseguire qualsiasi funzione e ripristinare i processi utente interrotti. Si occupa inoltre di gestire lo scheduling e il “dispatch” dei processi. Il concetto chiave è che il processo è un concetto applicabile solo al al programma utente. Il processo non ha interazione “voluta” con il SO. Kernel eseguito con i processi utente Tutte le funzioni del SO sono eseguite virtualemente e in modo indipendente con il processo utente. In pratica il SO è una collezione di routines. Il processo ha un suo ambiente (chiamato immagine) di esecuzione dove l’utente può richiamare ed eseguire le routines del SO. Il SO può arrivare a gestire n immagini. Quindi le immagini saranno formate dai componenti standard di un processo (PCB, user Stack, Heap, sezione dati ecc..) e dalle routine del SO utili al processo. Se un processo in esecuzione subisce interruzioni o trap (momento in cui il SO deve effettuare delle azioni), avviene il mode switch. In base alle circostanze il mode-switch cambia l’attività del SO da user-mode (esecuzione del codice utente) a kernel-mode (esecuzione del codice del sistema operativo) e viceversa. Nota: il mode-switch è l’alternativa leggera al context-swicth (situzione in cui il processo lascia la CPU in uso e il SO ne salva il PCB -&amp;gt; un PCB di un processo pronto viene caricato e il SO assegna la CPU a tale processo). Il processo va quindi in uno stato di nonrunning in modo da permettere al SO di operare (ed usare la CPU). Quando il SO termina le sue attività può decidere se eseguire il mode-switch (passando da kernel-mode a user-mode) in modo da riattivare il processo in stato di nonrunning o eseguire il context-switch in modo da far subentrare un nuovo processo. Kernel come processo Come per il precedente, il software del kernel è eseguito in kernel-mode e quello utente in user-mode ma invece di avere le funzioni del SO integrate con il processo utente, le funzioni kernel sono organizzate come processi separati. Rimane sempre l’alternativa context-switch in caso non si usi il mode-switch. Questo modello incoraggia un uso modulare del SO. Ha il vantaggio di essere utile in ambienti multiproessore dove ogni i processi del SO possono essere eseguiti su processori dedicati, migliorando le performance. Scheduling Lo scheduling è l’attività svolta dal SO per aumentare l’uso della CPU, in mdo che non resti mai inattiva. È condizionato dal tipo di elaborazione da fare, CPU bound o I/O bound. Nel primo si verificano sequenze più lunghe di operazioni svolte dalla CPU (CPU burst) mentre nel secondo le CPU burst sono più brevi. Ci sono due tipi di scheduler e quello più importante e usato e lo scheduler della CPU (o a breve termine). Questi prende il processo a cui assegnare la CPU dalla coda dei processi pronti. Questa coda non è necessariamente FIFO, ma può essere una coda con priorità o anche una lista concatenata. Nella coda dei processi pronti gli elementi sono presenti i PCB del processo (e non l’intero processo). Tipi di scheduling Se ne hanno 2 tipi: senza prelazione dove la CPU rimane in uso al processo fino alla sua fine esecuzione o passaggio in stato attesa. È il tipo di scheduling presente nei SO prima del 1995 e spesso è l’alternativa migliore su determiate piattaforne odierne. con prelazione (o cooperativo) dove la CPU viene forzatamente tolta al processo ed in uso sui SO dagli anni 1995 in poi. Per attuare la forzatura si usano ad es. i timer che danno luogo agli ambienti time-sharing dove il processo lascia la CPU dopo un quanto di tempo. Questo tipo di schedulign porta a race condition ossia quando un dato condiviso tra processi è modificato da più parti alterandone il significato per il processo che lo riusa trovandolo incoerente da quando lo aveva lasciato. A tale scopo nasce la necessità si usare sistemi di sincronizzazione per l’accesso ai dati condivisi. Semafori I semafori a valori binari vengono utilizzati per la mutua esclusione ossia un processo alla volta può accedere alla sezione critica. I semafori a valori interi trovano applicazione nel controllo dell’accesso ad una data risorsa presente in un numero finito di esemplari. Il semaforo è inizialmente impostato al numero di risorse disponibili.</summary></entry><entry><title type="html">Come funziona la rete di accesso</title><link href="https://www.hosthello.com/posts/la-rete-di-accesso" rel="alternate" type="text/html" title="Come funziona la rete di accesso" /><published>2020-07-10T00:00:00+02:00</published><updated>2020-07-10T00:00:00+02:00</updated><id>https://www.hosthello.com/posts/la-rete-di-accesso</id><content type="html" xml:base="https://www.hosthello.com/posts/la-rete-di-accesso">&lt;p&gt;&lt;img src=&quot;https://images.unsplash.com/photo-1528845922818-cc5462be9a63?ixlib=rb-1.2.1&amp;amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;amp;auto=format&amp;amp;fit=crop&amp;amp;w=2534&amp;amp;q=80&quot; alt=&quot;la rete di accesso&quot; title=&quot;la rete di accesso&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Sono reti che contegono gli host e sono definite come le reti più esterne nella logica dell’infrastruttura internet. Tali reti dovranno collegarsi a reti gerarchicamente più “interne” che servono per far si che i messaggi che partono da un host di una rete raggiungano un host presente in una rete diversa e lontana svariati chilometri.&lt;/p&gt;

&lt;p&gt;Le reti di accesso sono: residenziali, aziendali e di accesso mobile. Quelle residenziali sono le tipiche reti casalinghe che fanno uso della linea telefonica per accedere ad internet. Tale connessione tipicamente avviene con l’uso della tecnologia &lt;strong&gt;DSL&lt;/strong&gt; che fa uso del doppino telefonico per comunicare con il DSLAM presente all’interno di una compagnia telefonica o negli armadi di ripartizione presenti ai bordi delle strade.&lt;/p&gt;

&lt;p&gt;Se il cablaggio tra abitrazione e compagnia telefonica è solo su doppino telefonico, si ha l’ADSL pura. Se il cablaggio da casa fino all’armadio di ripartizione è su doppino telefonico e dall’armadio alla centrale della compagnia telefonica è in fibra, si ha FTTC (Fibre To The Cabinet). Se il cablaggio dall’abitazione verso l’armadio di ripartizione è in fibra e dall’armadio alla centrale di una compagnia telefonica è anche in fibra ottica, si parla di tecnologia FTTH (Fibre To The Home).&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../img/architetture-di-rete.jpg&quot; alt=&quot;picture alt&quot; title=&quot;Architettura di rete&quot; /&gt;&lt;/p&gt;

&lt;p&gt;I dati digitali provenienti da un host (es. PC) per essere inviati sul doppino telefonico devono essere convertiti in &lt;strong&gt;toni&lt;/strong&gt; ad alta frequenza. Questa conversione è svolta dal &lt;strong&gt;modem DSL&lt;/strong&gt; presente nelle abitazioni. A seguito della trasmissione dei toni sul doppino, questi arrivano al DSLAM che li riconverte in segnale digitale per viaggiare su cablaggi ad alta velocità.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Nota&lt;/strong&gt;: lo schema sotto permette di connettere un solo host ad internet e lo splitter è lo sdoppiatore telefono/modem (splitter DSL) che si inserisce sulla presa del telefono di casa.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../img/accesso-internet-tramite-adsl.jpg&quot; alt=&quot;picture alt&quot; title=&quot;accesso-internet-tramite-adsl.jpg&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Le linee residenziali trasportano sia dati che segnali telefonici. Quindi sul segmento che va dall’abitazione al DSLAM si hanno tre bande di frequenza diverse e non sovrapposte: una per il downstrem, uno per upstream e uno per il canale telefonico tradizionale a due vie. Quindi connessione internet e chiamata telefonica condividono lo stesso collegamento. Il DSLAM separerà i segnali dati dai segnali telefonici, inviando i primi verso la rete internet e i secondi verso la rete telefonica.&lt;/p&gt;

&lt;p&gt;Per permettere a più utenti di un’abitazione di connettersi in contemporanea su internet, è necessario usare un router all’interno della rete residenziale.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Nota&lt;/strong&gt;: nell’immagine sotto manca lo splitter DSL telefono/modem.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../img/accesso-internet-tramite-adsl-multihost.jpg&quot; alt=&quot;picture alt&quot; title=&quot;accesso-internet-tramite-adsl-multihost.jpg&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Quando nella rete residenziale si ha si fa uso dell’FTTH, in casa non si ha più il modem DSL ma si usa l’ONT (Optical Network Terminator) e nell’armadio di ripartizione si ha lo Splitter Ottico che combina più abitazioni su in una singola fibra ottica che si connette all’OLT (Optical Line Terminator) presente nella centrale della compagnia telefonica che converte i segnali ottici ed elettrici e li direziona verso un router connesso ad internet.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../img/accesso-internet-tramite-ftth.jpg&quot; alt=&quot;picture alt&quot; title=&quot;accesso-internet-tramite-ftth.jpg&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Le reti di accesso aziendale fanno uso tipicamente della tecnologia ethernet. All’interno della rete gli hosts sono connessi ad uno switch connesso a sua volta ad un router aziendale che si allaccia direttamente alla rete del’ISP per l’accesso ad internet.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../img/accesso-internet-tramite-ethernet.jpg&quot; alt=&quot;picture alt&quot; title=&quot;accesso-internet-tramite-ethernet.jpg&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Le reti ad accesso mobile sono le reti con tecnologia WiFi che permettono di creare reti &lt;strong&gt;LAN wireless&lt;/strong&gt; e &lt;strong&gt;accesso wireless su scala geografica&lt;/strong&gt;. Le prime sono realizzabili con l’ausilio di stazioni base chiamate &lt;em&gt;access point&lt;/em&gt; dalla dimensione contenuta e si usano in ambienti residenziali, aziendali e commerciali. Le seconde sono realizzabili con l’ausilio di stazioni base tipo antenne radio di dimensione più sostenute e permettono un raggio di copertura maggiore, usato per per l’accesso con dispositivi quali smartphone o altro.&lt;/p&gt;</content><author><name>Ivan</name></author><summary type="html">Sono reti che contegono gli host e sono definite come le reti più esterne nella logica dell’infrastruttura internet. Tali reti dovranno collegarsi a reti gerarchicamente più “interne” che servono per far si che i messaggi che partono da un host di una rete raggiungano un host presente in una rete diversa e lontana svariati chilometri. Le reti di accesso sono: residenziali, aziendali e di accesso mobile. Quelle residenziali sono le tipiche reti casalinghe che fanno uso della linea telefonica per accedere ad internet. Tale connessione tipicamente avviene con l’uso della tecnologia DSL che fa uso del doppino telefonico per comunicare con il DSLAM presente all’interno di una compagnia telefonica o negli armadi di ripartizione presenti ai bordi delle strade. Se il cablaggio tra abitrazione e compagnia telefonica è solo su doppino telefonico, si ha l’ADSL pura. Se il cablaggio da casa fino all’armadio di ripartizione è su doppino telefonico e dall’armadio alla centrale della compagnia telefonica è in fibra, si ha FTTC (Fibre To The Cabinet). Se il cablaggio dall’abitazione verso l’armadio di ripartizione è in fibra e dall’armadio alla centrale di una compagnia telefonica è anche in fibra ottica, si parla di tecnologia FTTH (Fibre To The Home). I dati digitali provenienti da un host (es. PC) per essere inviati sul doppino telefonico devono essere convertiti in toni ad alta frequenza. Questa conversione è svolta dal modem DSL presente nelle abitazioni. A seguito della trasmissione dei toni sul doppino, questi arrivano al DSLAM che li riconverte in segnale digitale per viaggiare su cablaggi ad alta velocità. Nota: lo schema sotto permette di connettere un solo host ad internet e lo splitter è lo sdoppiatore telefono/modem (splitter DSL) che si inserisce sulla presa del telefono di casa. Le linee residenziali trasportano sia dati che segnali telefonici. Quindi sul segmento che va dall’abitazione al DSLAM si hanno tre bande di frequenza diverse e non sovrapposte: una per il downstrem, uno per upstream e uno per il canale telefonico tradizionale a due vie. Quindi connessione internet e chiamata telefonica condividono lo stesso collegamento. Il DSLAM separerà i segnali dati dai segnali telefonici, inviando i primi verso la rete internet e i secondi verso la rete telefonica. Per permettere a più utenti di un’abitazione di connettersi in contemporanea su internet, è necessario usare un router all’interno della rete residenziale. Nota: nell’immagine sotto manca lo splitter DSL telefono/modem. Quando nella rete residenziale si ha si fa uso dell’FTTH, in casa non si ha più il modem DSL ma si usa l’ONT (Optical Network Terminator) e nell’armadio di ripartizione si ha lo Splitter Ottico che combina più abitazioni su in una singola fibra ottica che si connette all’OLT (Optical Line Terminator) presente nella centrale della compagnia telefonica che converte i segnali ottici ed elettrici e li direziona verso un router connesso ad internet. Le reti di accesso aziendale fanno uso tipicamente della tecnologia ethernet. All’interno della rete gli hosts sono connessi ad uno switch connesso a sua volta ad un router aziendale che si allaccia direttamente alla rete del’ISP per l’accesso ad internet. Le reti ad accesso mobile sono le reti con tecnologia WiFi che permettono di creare reti LAN wireless e accesso wireless su scala geografica. Le prime sono realizzabili con l’ausilio di stazioni base chiamate access point dalla dimensione contenuta e si usano in ambienti residenziali, aziendali e commerciali. Le seconde sono realizzabili con l’ausilio di stazioni base tipo antenne radio di dimensione più sostenute e permettono un raggio di copertura maggiore, usato per per l’accesso con dispositivi quali smartphone o altro.</summary></entry><entry><title type="html">Lista di elementi concatenati semplici</title><link href="https://www.hosthello.com/posts/liste-concatenate" rel="alternate" type="text/html" title="Lista di elementi concatenati semplici" /><published>2020-01-03T00:00:00+01:00</published><updated>2020-01-03T00:00:00+01:00</updated><id>https://www.hosthello.com/posts/liste-concatenate</id><content type="html" xml:base="https://www.hosthello.com/posts/liste-concatenate">&lt;p&gt;La lista di elementi concatenate semplici sono un insieme di nodi dove ogni nodo è inteso come elemento della lista.&lt;/p&gt;

&lt;h2 id=&quot;lista-della-spesa-su-carta&quot;&gt;Lista della spesa su carta&lt;/h2&gt;

&lt;p&gt;Se prendiamo una tipica lista della spesa scritta a &lt;strong&gt;penna&lt;/strong&gt; su un foglio di carta, potrebbe apparire come segue. Consideriamo la penna perchè i prodotti che scriviamo sulla carta vogliamo trattarli come non cancellabili dal foglio di carta stesso, ma piuttosto depennabili.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;Lista spesa&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;acqua&lt;/li&gt;
  &lt;li&gt;caffe&lt;/li&gt;
  &lt;li&gt;sapone&lt;/li&gt;
  &lt;li&gt;ecc…&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;Rapportando la lista sopra alla &lt;em&gt;lista di elementi concatenati&lt;/em&gt; che andremo a trattare, ogni elemento della lista spesa (esempio il caffè) è un &lt;strong&gt;nodo&lt;/strong&gt; della lista concatenata.&lt;/p&gt;

&lt;p&gt;Il termine concatenato fa riferimento al fatto che il prodotto &lt;em&gt;corrente&lt;/em&gt; sulla carta è disposto in modo da avere un prodotto &lt;em&gt;predecente&lt;/em&gt; al corrente e uno &lt;em&gt;successivo&lt;/em&gt;: il prodotto precedente a &lt;strong&gt;caffè&lt;/strong&gt; è &lt;strong&gt;acqua&lt;/strong&gt; mentre il successivo è &lt;strong&gt;sapone&lt;/strong&gt;. Ovviamente esiste il caso in cui il primo prodotto (acqua) non ha un precedente e che l’ultimo prodotto (sapone) non ha un successivo.&lt;/p&gt;

&lt;p&gt;Di seguito alcune azioni che possiamo compiere sulla lista scritta a penna su carta:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;per aggiungere un prodotto, prendiamo la penna e lo scriviamo inserendolo a fine lista.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;per cancellare un prodotto lo depenniamo (tiriamo una riga sul prodotto) e lo sostituiamo scrivendo un nuovo prodotto al suo fianco.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;oppure è possibile cancellare il prodotto (depennandolo) e basta.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;ecc…&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Tenendo a mente queste “azioni” eseguibili sulla lista scritta su foglio di carta, andiamo a trattare la lista con elementi concatenati scritta in &lt;code class=&quot;highlighter-rouge&quot;&gt;C&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&quot;lista-concatenata-in-c&quot;&gt;Lista concatenata in &lt;code class=&quot;highlighter-rouge&quot;&gt;C&lt;/code&gt;.&lt;/h2&gt;

&lt;p&gt;Si parte dal presupposto che la lista concatenata &lt;strong&gt;deve&lt;/strong&gt; far uso delle &lt;strong&gt;strutture&lt;/strong&gt;. Le strutture usate per creare la lista e i suoi elementi possono essere modellate in modi diversi. Questo aspetto sarà chiaro più avanti.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//librerire usate da alcune funzioni
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdbool.h&amp;gt;

//dichiarazione struttura secondaria
struct node_t{
	int value;
	struct node_t *next;
};

//dichiarazione struttura principale
struct list_t{
	struct node_t *head; //deve essere già dichiarata la struct node_t
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Si dichiara la struttura principale &lt;code class=&quot;highlighter-rouge&quot;&gt;struct list_t&lt;/code&gt; formata da una variabile che dovrà contenere un indirizzo di memoria (quindi è una variabile puntatore). Possiamo vedere che la struttura principale è in seconda posizione rispetto alla struttura secondaria. Questo perchè &lt;code class=&quot;highlighter-rouge&quot;&gt;struct list_t&lt;/code&gt; contiene il puntatore &lt;code class=&quot;highlighter-rouge&quot;&gt;*head&lt;/code&gt; di tipo &lt;code class=&quot;highlighter-rouge&quot;&gt;struct node_t&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;struct node_t&lt;/code&gt; che deve esser già dichiarato per essese usato da &lt;code class=&quot;highlighter-rouge&quot;&gt;struct list_t&lt;/code&gt;. Diversamente si ha un errore di compilazione.&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;//firme funzioni&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;list_t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;new_list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;insert_on_head&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;list_t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;insert_on_tail&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;list_t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;contains&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;list_t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;remove_from_list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;list_t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;list_t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;empty_list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;list_t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;free_list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;list_t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Guardando le firme delle funzioni possiamo vedere che ogni funzione riceve la lista per &lt;em&gt;indirizzo&lt;/em&gt;.&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;//funzione principale&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(){&lt;/span&gt;
    
    &lt;span class=&quot;c1&quot;&gt;//dichiaro un puntatore di tipo struct list_t&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;list_t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;list&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;new_list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;

	&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;insert_on_head&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;11&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;20&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;insert_on_tail&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;contains&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)){&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;list contains the value 5&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;list does not contain the value 5&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;contains&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;30&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)){&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;list contains the value 30&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;list does not contain the value 30&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

	&lt;span class=&quot;n&quot;&gt;remove_from_list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;contains&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)){&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;list contains the value 5&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;list does not contain the value 5&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

	&lt;span class=&quot;n&quot;&gt;empty_list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;insert_on_tail&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;remove_from_list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

	&lt;span class=&quot;n&quot;&gt;free_list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;



&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;list_t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;new_list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(){&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;list_t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;list&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;list_t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;malloc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;list_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;head&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;insert_on_head&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;list_t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;node_t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;node&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;node_t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;malloc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;node_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;head&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;head&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;insert_on_tail&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;list_t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;head&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;insert_on_head&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;node_t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;current&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;head&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;current&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;current&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;current&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;node_t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;node&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;node_t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;malloc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;node_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
	        &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;current&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;contains&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;list_t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;node_t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;current&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;head&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;current&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;current&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
			&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;current&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;current&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;	

&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;remove_from_list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;list_t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;node_t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;current&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;head&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;node_t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;previous&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;current&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;current&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
			&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;current&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;head&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
				&lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;head&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;current&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
				&lt;span class=&quot;n&quot;&gt;free&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;current&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
			&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
			&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
				&lt;span class=&quot;n&quot;&gt;previous&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;current&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
				&lt;span class=&quot;n&quot;&gt;free&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;current&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
			&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
			&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;previous&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;current&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;current&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;current&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;list_t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;head&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;list is empty&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

	&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;node_t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;current&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;head&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;current&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;%i &quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;current&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;current&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;current&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;


&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;empty_list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;list_t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;node_t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;current&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;head&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;node_t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;previous&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;current&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;previous&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;free&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;previous&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;previous&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;current&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;current&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;current&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;previous&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;free&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;previous&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;head&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;


&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;free_list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;list_t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;empty_list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;free&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;//creazione lista &lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//list è stato allocato con malloc())&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//*head è puntato a NULL (= lista vuota, senza elementi)&lt;/span&gt;
   &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mh&quot;&gt;0x55869911b010&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;  
    &lt;span class=&quot;err&quot;&gt;↑&lt;/span&gt;     &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; 
    &lt;span class=&quot;err&quot;&gt;│&lt;/span&gt;     &lt;span class=&quot;err&quot;&gt;↑&lt;/span&gt;
   &lt;span class=&quot;n&quot;&gt;list&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;head&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;//nota: head deve contenere un indirizzo di una struct dello stesso tipo del puntatore *head. Quando c'è NULL non si ha nessun indirizzo per cui il puntatore *head non punta a niente&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;//creazione elemento e inserimento in testa&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// &lt;/span&gt;
   &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mh&quot;&gt;0x55869911b010&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; 
    &lt;span class=&quot;err&quot;&gt;↑&lt;/span&gt;     &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mh&quot;&gt;0x55869911b440&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
    &lt;span class=&quot;err&quot;&gt;│&lt;/span&gt;     &lt;span class=&quot;err&quot;&gt;↑&lt;/span&gt;
   &lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;head&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;┬&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt; 
               &lt;span class=&quot;err&quot;&gt;└&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;

   &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mh&quot;&gt;0x55869911b440&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
   &lt;span class=&quot;err&quot;&gt;↑&lt;/span&gt;
   &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;┬&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;
   		 &lt;span class=&quot;err&quot;&gt;└&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;event ┬ .sdate ┬ .day       10
      │        ├ .month     6
      │        └ .year      2016
      └ .stime ┬ .hour      15
               ├ .minute    33
               └ .second    59&lt;/p&gt;</content><author><name>Ivan Garrini</name></author><summary type="html">La lista di elementi concatenate semplici sono un insieme di nodi dove ogni nodo è inteso come elemento della lista. Lista della spesa su carta Se prendiamo una tipica lista della spesa scritta a penna su un foglio di carta, potrebbe apparire come segue. Consideriamo la penna perchè i prodotti che scriviamo sulla carta vogliamo trattarli come non cancellabili dal foglio di carta stesso, ma piuttosto depennabili. Lista spesa acqua caffe sapone ecc… Rapportando la lista sopra alla lista di elementi concatenati che andremo a trattare, ogni elemento della lista spesa (esempio il caffè) è un nodo della lista concatenata. Il termine concatenato fa riferimento al fatto che il prodotto corrente sulla carta è disposto in modo da avere un prodotto predecente al corrente e uno successivo: il prodotto precedente a caffè è acqua mentre il successivo è sapone. Ovviamente esiste il caso in cui il primo prodotto (acqua) non ha un precedente e che l’ultimo prodotto (sapone) non ha un successivo. Di seguito alcune azioni che possiamo compiere sulla lista scritta a penna su carta: per aggiungere un prodotto, prendiamo la penna e lo scriviamo inserendolo a fine lista. per cancellare un prodotto lo depenniamo (tiriamo una riga sul prodotto) e lo sostituiamo scrivendo un nuovo prodotto al suo fianco. oppure è possibile cancellare il prodotto (depennandolo) e basta. ecc… Tenendo a mente queste “azioni” eseguibili sulla lista scritta su foglio di carta, andiamo a trattare la lista con elementi concatenati scritta in C. Lista concatenata in C. Si parte dal presupposto che la lista concatenata deve far uso delle strutture. Le strutture usate per creare la lista e i suoi elementi possono essere modellate in modi diversi. Questo aspetto sarà chiaro più avanti. //librerire usate da alcune funzioni #include &amp;lt;stdlib.h&amp;gt; #include &amp;lt;stdio.h&amp;gt; #include &amp;lt;stdbool.h&amp;gt; //dichiarazione struttura secondaria struct node_t{ int value; struct node_t *next; }; //dichiarazione struttura principale struct list_t{ struct node_t *head; //deve essere già dichiarata la struct node_t }; Si dichiara la struttura principale struct list_t formata da una variabile che dovrà contenere un indirizzo di memoria (quindi è una variabile puntatore). Possiamo vedere che la struttura principale è in seconda posizione rispetto alla struttura secondaria. Questo perchè struct list_t contiene il puntatore *head di tipo struct node_t. struct node_t che deve esser già dichiarato per essese usato da struct list_t. Diversamente si ha un errore di compilazione. //firme funzioni struct list_t *new_list(); void insert_on_head(struct list_t *list, int value); void insert_on_tail(struct list_t *list, int value); bool contains(struct list_t *list, int value); void remove_from_list(struct list_t *list, int value); void print(struct list_t *list); void empty_list(struct list_t *list); void free_list(struct list_t *list); Guardando le firme delle funzioni possiamo vedere che ogni funzione riceve la lista per indirizzo. //funzione principale void main(){ //dichiaro un puntatore di tipo struct list_t struct list_t *list = new_list(); int v; for(v = 0; v &amp;lt; 10; v++){ insert_on_head(list, v); } print(list); for(v = 11; v &amp;lt; 20; v++){ insert_on_tail(list, v); } print(list); if(contains(list, 5)){ printf(&quot;list contains the value 5\n&quot;); } else{ printf(&quot;list does not contain the value 5\n&quot;); } if(contains(list, 30)){ printf(&quot;list contains the value 30\n&quot;); } else{ printf(&quot;list does not contain the value 30\n&quot;); } remove_from_list(list, 5); print(list); if(contains(list, 5)){ printf(&quot;list contains the value 5\n&quot;); } else{ printf(&quot;list does not contain the value 5\n&quot;); } empty_list(list); print(list); insert_on_tail(list, 5); print(list); remove_from_list(list, 5); print(list); free_list(list); }; struct list_t *new_list(){ struct list_t *list = (struct list_t *)malloc(sizeof(struct list_t)); list-&amp;gt;head = NULL; return list; }; void insert_on_head(struct list_t *list, int value){ struct node_t *node = (struct node_t *)malloc(sizeof(struct node_t)); node-&amp;gt;value = value; node-&amp;gt;next = list-&amp;gt;head; list-&amp;gt;head = node; }; void insert_on_tail(struct list_t *list, int value){ if(list-&amp;gt;head == NULL){ insert_on_head(list, value); } else{ struct node_t *current = list-&amp;gt;head; while(current-&amp;gt;next != NULL){ current = current-&amp;gt;next; } struct node_t *node = (struct node_t *)malloc(sizeof(struct node_t)); node-&amp;gt;value = value; node-&amp;gt;next = NULL; current-&amp;gt;next = node; } }; bool contains(struct list_t *list, int value){ struct node_t *current = list-&amp;gt;head; while(current != NULL){ if(current-&amp;gt;value == value){ return true; } current = current-&amp;gt;next; } return false; }; void remove_from_list(struct list_t *list, int value){ struct node_t *current = list-&amp;gt;head; struct node_t *previous = NULL; while(current != NULL){ if(current-&amp;gt;value == value){ if(current == list-&amp;gt;head){ list-&amp;gt;head = current-&amp;gt;next; free(current); } else{ previous-&amp;gt;next = current-&amp;gt;next; free(current); } return; } previous = current; current = current-&amp;gt;next; } }; void print(struct list_t *list){ if(list-&amp;gt;head == NULL){ printf(&quot;list is empty\n&quot;); return; } struct node_t *current = list-&amp;gt;head; while(current != NULL){ printf(&quot;%i &quot;, current-&amp;gt;value); current = current-&amp;gt;next; } printf(&quot;\n&quot;); }; void empty_list(struct list_t *list){ struct node_t *current = list-&amp;gt;head; struct node_t *previous = NULL; while(current != NULL){ if(previous != NULL){ free(previous); } previous = current; current = current-&amp;gt;next; } if(previous != NULL){ free(previous); } list-&amp;gt;head = NULL; }; void free_list(struct list_t *list){ empty_list(list); free(list); }; //creazione lista //list è stato allocato con malloc()) //*head è puntato a NULL (= lista vuota, senza elementi) [0x55869911b010] ↑ [NULL] │ ↑ list - *head //nota: head deve contenere un indirizzo di una struct dello stesso tipo del puntatore *head. Quando c'è NULL non si ha nessun indirizzo per cui il puntatore *head non punta a niente //creazione elemento e inserimento in testa // [0x55869911b010] ↑ [0x55869911b440] │ ↑ list-*head ┬ .value └ *next [0x55869911b440] ↑ node ┬ .value = 100 └ *next = NULL event ┬ .sdate ┬ .day 10 │ ├ .month 6 │ └ .year 2016 └ .stime ┬ .hour 15 ├ .minute 33 └ .second 59</summary></entry><entry><title type="html">Sommare un numero con i suoi successivi in modo posizionale.</title><link href="https://www.hosthello.com/posts/sommare-un-numero-con-i-suoi-successivi-in-modo-posizionale" rel="alternate" type="text/html" title="Sommare un numero con i suoi successivi in modo posizionale." /><published>2017-09-19T00:00:00+02:00</published><updated>2017-09-19T00:00:00+02:00</updated><id>https://www.hosthello.com/posts/sommare-un-numero-con-i-suoi-successivi-in-modo-posizionale</id><content type="html" xml:base="https://www.hosthello.com/posts/sommare-un-numero-con-i-suoi-successivi-in-modo-posizionale">&lt;p&gt;Per ogni numero in un array di interi,&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;se il numero è nella posizione corrente &lt;strong&gt;dispari&lt;/strong&gt; dovrà essere sommato con i suoi &lt;strong&gt;successivi in posizione dispari&lt;/strong&gt;.&lt;/li&gt;
  &lt;li&gt;se il numero è nella posizione corrente &lt;strong&gt;pari&lt;/strong&gt; dovrà essere sommato con i suoi &lt;strong&gt;successivi in posizione pari&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;        ┌ posizione pari
        │  ┌ posizione dispari
        │  │  ... 
arrayA {1, 2, 3, 4, 5 }; //array iniziale
arrayA {9, 6, 8, 4, 5 }; //array finale
        │  │  │  │  │
        │  │  │  │  └ = 5
        │  │  │  └ = 4
        │  │  └ = 3 + 5 = 8
        │  └ = 2 + 4 = 6
        └ = 1 + 3 + 5 = 9
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;strategia&quot;&gt;Strategia&lt;/h2&gt;

&lt;p&gt;Per poter realizzare quanto sopra, si adotta la seguente strategia:&lt;/p&gt;

&lt;h3 id=&quot;numeri-pari&quot;&gt;Numeri pari&lt;/h3&gt;

&lt;p&gt;Prendo ogni numero in posizione pari e lo sommo. Conservo la somma.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sommaPari = 1 + 3 + 5 = 9
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Ora, conosco la somma &lt;strong&gt;totale&lt;/strong&gt; dei numeri in posizione pari. Se scansiono l’array andando con l’indice solo sui numeri pari, posso trovare &lt;strong&gt;la somma degli elementi successivi al numero in posizione corrente&lt;/strong&gt; così: tolgo dalla somma &lt;strong&gt;totale&lt;/strong&gt; i numeri &lt;strong&gt;precendenti&lt;/strong&gt; all’elemento in &lt;em&gt;posizione corrente&lt;/em&gt; (per numero in &lt;em&gt;posizione corrente&lt;/em&gt; si intende il numero su cui mi trovo con l’indice array).&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Ricorda.&lt;/strong&gt; Lo zero è considerato un numero pari (&lt;a href=&quot;https://it.wikipedia.org/wiki/Parit%C3%A0_dello_zero&quot; title=&quot;Parità dello zero&quot;&gt;fonte&lt;/a&gt;).&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 1^ iterazione. Sono stati omessi i numeri dispari.

        ┌ nCorrente[i]
        │  
arrayA {1, -, 3, -, 5 }; //array iniziale
arrayA {9, -, 3, -, 5 }; //array finale
        │     │
        │     └ a fine iterazione sarà il prossimo nCorrente[i]
        └ sommaSuccessiviCorrente
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sommaSuccessiviCorrente&lt;/code&gt; = &lt;code class=&quot;highlighter-rouge&quot;&gt;sommaPari&lt;/code&gt; - &lt;code class=&quot;highlighter-rouge&quot;&gt;nCorrente[i-2]&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;9&lt;/code&gt; ← &lt;code class=&quot;highlighter-rouge&quot;&gt;9&lt;/code&gt; - &lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Nota.&lt;/strong&gt; Guarda di seguito il perchè di &lt;code class=&quot;highlighter-rouge&quot;&gt;nCorrente[i-2]&lt;/code&gt;.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 2^ iterazione. Sono stati omessi i numeri dispari.

        ┌ nCorrente[i-2]
        │     ┌ nCorrente[i]
        │     │  
arrayA {1, -, 3, -, 5 }; //array iniziale
arrayA {9, -, 8, -, 5 }; //array finale
              │     │
              │     └ a fine iterazione sarà il prossimo nCorrente[i]
              └ sommaSuccessiviCorrente      
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sommaSuccessiviCorrente&lt;/code&gt; = &lt;code class=&quot;highlighter-rouge&quot;&gt;sommaPari&lt;/code&gt; - &lt;code class=&quot;highlighter-rouge&quot;&gt;nCorrente[i-2]&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;8&lt;/code&gt; ← &lt;code class=&quot;highlighter-rouge&quot;&gt;9&lt;/code&gt; - &lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Nota.&lt;/strong&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;nCorrente[i-2]&lt;/code&gt; perchè &lt;strong&gt;non&lt;/strong&gt; si vuole il numero successivo (che in questo caso sarebbe dispari), ma il numero di due posizioni avanti.&lt;/p&gt;

&lt;h4 id=&quot;lultimo-elmento-dei-pari-rimane-invariato&quot;&gt;L’ultimo elmento dei pari rimane invariato&lt;/h4&gt;

&lt;p&gt;Se i numeri pari sono &lt;code class=&quot;highlighter-rouge&quot;&gt;n&lt;/code&gt;, sipossono svolgere &lt;code class=&quot;highlighter-rouge&quot;&gt;n - 1&lt;/code&gt; iterazioni: quindi l’ultimo elemento rimane invariato. In termini di prestazioni ha poco senso perchè comunque si tratta di una sola iterazione. Ciò è fattibile agendo sull’indice dell’array.&lt;/p&gt;

&lt;h3 id=&quot;numeri-dispari&quot;&gt;Numeri dispari&lt;/h3&gt;

&lt;p&gt;Per i numeri dispari si fa la stessa cosa. Ma bisogna ricordare che nella prima iterazione l’indice del &lt;strong&gt;numero corrente&lt;/strong&gt; sarà posizionato sul secondo elemento dell’array.&lt;/p&gt;

&lt;h2 id=&quot;codice&quot;&gt;Codice&lt;/h2&gt;

&lt;p&gt;Segue la funzione che esegue somma degli elementi successvi a quello corrente.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
 * PER OGNI NUMERO IN POSIZIONE DISPARI, SOMMALO CON I SUOI SUCCESSIVI
 * DISPARI. INFINE STAMPARE LA SOMMA DI OGNI NUMERO. 
 * STESSA COSA PER I NUMERI DI POSIZIONE PARI.
 * 
 * Es:  
 * arrayA {1, 2, 3, 4, 5 }; //array prima della trasformazione
 * arrayA {9, 6, 8, 4, 5 }; //array dopo la trasformazione
 * 
 * 1+3+5 = 9;
 *   2+4 = 6;
 * ecc..
 *      
*/
#include &amp;lt;stdio.h&amp;gt;

/* dichiarazione prototipo funzioni */
void fillArray( int * , int );
void somma_in_array( int * , int );
int n_elementi();

/* funz. principale */
int main( void ){
    // chiedo dimensione per array
    int lung = n_elementi();

    int array[lung];
    int *ptrArray = array; //genero un puntatore ad un array
    
    //chiamo funzione che riempie array con dati interi e restituisce lunghezza array.
    fillArray( ptrArray, lung );

    // stampo array originale (prima dell'elaborazione)
    int i;
    printf(&quot;arrayOriginale { &quot;);
    for( i = 0; i &amp;lt; lung; i++ ){
        printf( &quot;%d &quot;, array[i] );
    }
    printf(&quot;}\n&quot;);

    
    // chiamo funzione per trasformare array
    somma_in_array( ptrArray, lung );
    
    // stampo array originale (prima dell'elaborazione)
    printf(&quot;arrayFinale    { &quot;);
    for( i = 0; i &amp;lt; lung; i++ ){
        printf( &quot;%d &quot;, array[i] );
    }
    printf(&quot;}\n\n&quot;);
    
    return 0;
}

/* funzione chiede quantità valori */
int n_elementi(){
    int n;
    printf(&quot;Quanti valori vuoi inserire? &quot;);
    scanf(&quot;%i&quot;, &amp;amp;n);

    return n;
}

/* funzione riempimento array con numeri inseriti dall'utente */
void fillArray( int *array_ptr, int n ){
    int i, value;     
    
    // chiedo inserimento valori
    printf( &quot;\nInserisci %i valori. \n&quot;, n );
    for( i = 0; i &amp;lt; n; i++ ){
        printf( &quot;Valore #%i: &quot;, i + 1 );
        scanf( &quot;%i&quot;, &amp;amp;value );    
        array_ptr[i] = value;
    }
    printf( &quot;\n&quot; );
    
}

/**
 * Funzione di somma elementi successivi al corrente
 *
 * @param *array_ptr: array di tipo puntatore
 * @param n: dimensione array
 * 
 * @return void
 *
*/
void somma_in_array( int *current, int n ){    
    int i, k, j; 

    // Array temporaneo stessa dimensione dell'originale. 
    // usato per non compromettere l'originale. 
    // Conterrà le somme per posizione pari/dispari del numero corrente.
    
    int temp[n];
    for( i = 0; i &amp;lt; n; i++ ){ 
        temp[i] = 0; 
    }

    /* Parte principale che svolge tutto il lavoro di somma. */

    int pariDispari;

    // Scopo del ciclo seguente è inizializzare i puntatori per i cicli interni.
    // Per farlo si usa l'indice pariDispari.
    // - pariDispari = 0 i cicli interni si inizializzano sui numeri pari.
    // - pariDispari = 1 i cicli interni si inizializzano sui numeri dispari.

    for (pariDispari = 0; pariDispari &amp;lt; 2; pariDispari++){

        // Trovo totale numeri in posizione pari/dispari 
        int totale = 0;
        for(k = pariDispari; k &amp;lt; n; k = k + 2){
            totale = totale + current[k]; // somma dei dispari
        }
        
        // Somma numeri successivi al corrente in posizione pari/dispari.
        // La somma avviene con il numero corrente e il totale dei suoi precedenti.

        int totalePrecedenti = 0;
        
        for( i = pariDispari; i &amp;lt; n; i = i + 2 ){
            
            // calcolo totale precedenti
            for( k = pariDispari; k &amp;lt; i ; k = k + 2 ){
                totalePrecedenti = totalePrecedenti + current[k];  
            }
            
            // calcolo somma dei numeri successivi al corrente
            temp[i] = totale - totalePrecedenti; 
            
            // azzero per nuova somma per futura iterazione
            totalePrecedenti = 0; 
        }
    }

   /* passo i dati dall'array temporaneo all'array del puntatore */
    for( i = 0; i &amp;lt; n; i++ ) {
        current[i] = temp[i];
    }    
    
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>Mr. Jim</name></author><summary type="html">Per ogni numero in un array di interi, se il numero è nella posizione corrente dispari dovrà essere sommato con i suoi successivi in posizione dispari. se il numero è nella posizione corrente pari dovrà essere sommato con i suoi successivi in posizione pari ┌ posizione pari │ ┌ posizione dispari │ │ ... arrayA {1, 2, 3, 4, 5 }; //array iniziale arrayA {9, 6, 8, 4, 5 }; //array finale │ │ │ │ │ │ │ │ │ └ = 5 │ │ │ └ = 4 │ │ └ = 3 + 5 = 8 │ └ = 2 + 4 = 6 └ = 1 + 3 + 5 = 9 Strategia Per poter realizzare quanto sopra, si adotta la seguente strategia: Numeri pari Prendo ogni numero in posizione pari e lo sommo. Conservo la somma. sommaPari = 1 + 3 + 5 = 9 Ora, conosco la somma totale dei numeri in posizione pari. Se scansiono l’array andando con l’indice solo sui numeri pari, posso trovare la somma degli elementi successivi al numero in posizione corrente così: tolgo dalla somma totale i numeri precendenti all’elemento in posizione corrente (per numero in posizione corrente si intende il numero su cui mi trovo con l’indice array). Ricorda. Lo zero è considerato un numero pari (fonte). // 1^ iterazione. Sono stati omessi i numeri dispari. ┌ nCorrente[i] │ arrayA {1, -, 3, -, 5 }; //array iniziale arrayA {9, -, 3, -, 5 }; //array finale │ │ │ └ a fine iterazione sarà il prossimo nCorrente[i] └ sommaSuccessiviCorrente sommaSuccessiviCorrente = sommaPari - nCorrente[i-2] 9 ← 9 - 0 Nota. Guarda di seguito il perchè di nCorrente[i-2]. // 2^ iterazione. Sono stati omessi i numeri dispari. ┌ nCorrente[i-2] │ ┌ nCorrente[i] │ │ arrayA {1, -, 3, -, 5 }; //array iniziale arrayA {9, -, 8, -, 5 }; //array finale │ │ │ └ a fine iterazione sarà il prossimo nCorrente[i] └ sommaSuccessiviCorrente sommaSuccessiviCorrente = sommaPari - nCorrente[i-2] 8 ← 9 - 1 Nota. nCorrente[i-2] perchè non si vuole il numero successivo (che in questo caso sarebbe dispari), ma il numero di due posizioni avanti. L’ultimo elmento dei pari rimane invariato Se i numeri pari sono n, sipossono svolgere n - 1 iterazioni: quindi l’ultimo elemento rimane invariato. In termini di prestazioni ha poco senso perchè comunque si tratta di una sola iterazione. Ciò è fattibile agendo sull’indice dell’array. Numeri dispari Per i numeri dispari si fa la stessa cosa. Ma bisogna ricordare che nella prima iterazione l’indice del numero corrente sarà posizionato sul secondo elemento dell’array. Codice Segue la funzione che esegue somma degli elementi successvi a quello corrente. /** * PER OGNI NUMERO IN POSIZIONE DISPARI, SOMMALO CON I SUOI SUCCESSIVI * DISPARI. INFINE STAMPARE LA SOMMA DI OGNI NUMERO. * STESSA COSA PER I NUMERI DI POSIZIONE PARI. * * Es: * arrayA {1, 2, 3, 4, 5 }; //array prima della trasformazione * arrayA {9, 6, 8, 4, 5 }; //array dopo la trasformazione * * 1+3+5 = 9; * 2+4 = 6; * ecc.. * */ #include &amp;lt;stdio.h&amp;gt; /* dichiarazione prototipo funzioni */ void fillArray( int * , int ); void somma_in_array( int * , int ); int n_elementi(); /* funz. principale */ int main( void ){ // chiedo dimensione per array int lung = n_elementi(); int array[lung]; int *ptrArray = array; //genero un puntatore ad un array //chiamo funzione che riempie array con dati interi e restituisce lunghezza array. fillArray( ptrArray, lung ); // stampo array originale (prima dell'elaborazione) int i; printf(&quot;arrayOriginale { &quot;); for( i = 0; i &amp;lt; lung; i++ ){ printf( &quot;%d &quot;, array[i] ); } printf(&quot;}\n&quot;); // chiamo funzione per trasformare array somma_in_array( ptrArray, lung ); // stampo array originale (prima dell'elaborazione) printf(&quot;arrayFinale { &quot;); for( i = 0; i &amp;lt; lung; i++ ){ printf( &quot;%d &quot;, array[i] ); } printf(&quot;}\n\n&quot;); return 0; } /* funzione chiede quantità valori */ int n_elementi(){ int n; printf(&quot;Quanti valori vuoi inserire? &quot;); scanf(&quot;%i&quot;, &amp;amp;n); return n; } /* funzione riempimento array con numeri inseriti dall'utente */ void fillArray( int *array_ptr, int n ){ int i, value; // chiedo inserimento valori printf( &quot;\nInserisci %i valori. \n&quot;, n ); for( i = 0; i &amp;lt; n; i++ ){ printf( &quot;Valore #%i: &quot;, i + 1 ); scanf( &quot;%i&quot;, &amp;amp;value ); array_ptr[i] = value; } printf( &quot;\n&quot; ); } /** * Funzione di somma elementi successivi al corrente * * @param *array_ptr: array di tipo puntatore * @param n: dimensione array * * @return void * */ void somma_in_array( int *current, int n ){ int i, k, j; // Array temporaneo stessa dimensione dell'originale. // usato per non compromettere l'originale. // Conterrà le somme per posizione pari/dispari del numero corrente. int temp[n]; for( i = 0; i &amp;lt; n; i++ ){ temp[i] = 0; } /* Parte principale che svolge tutto il lavoro di somma. */ int pariDispari; // Scopo del ciclo seguente è inizializzare i puntatori per i cicli interni. // Per farlo si usa l'indice pariDispari. // - pariDispari = 0 i cicli interni si inizializzano sui numeri pari. // - pariDispari = 1 i cicli interni si inizializzano sui numeri dispari. for (pariDispari = 0; pariDispari &amp;lt; 2; pariDispari++){ // Trovo totale numeri in posizione pari/dispari int totale = 0; for(k = pariDispari; k &amp;lt; n; k = k + 2){ totale = totale + current[k]; // somma dei dispari } // Somma numeri successivi al corrente in posizione pari/dispari. // La somma avviene con il numero corrente e il totale dei suoi precedenti. int totalePrecedenti = 0; for( i = pariDispari; i &amp;lt; n; i = i + 2 ){ // calcolo totale precedenti for( k = pariDispari; k &amp;lt; i ; k = k + 2 ){ totalePrecedenti = totalePrecedenti + current[k]; } // calcolo somma dei numeri successivi al corrente temp[i] = totale - totalePrecedenti; // azzero per nuova somma per futura iterazione totalePrecedenti = 0; } } /* passo i dati dall'array temporaneo all'array del puntatore */ for( i = 0; i &amp;lt; n; i++ ) { current[i] = temp[i]; } }</summary></entry><entry><title type="html">Puntatori e variabili</title><link href="https://www.hosthello.com/posts/puntatori" rel="alternate" type="text/html" title="Puntatori e variabili" /><published>2017-05-27T00:00:00+02:00</published><updated>2017-05-27T00:00:00+02:00</updated><id>https://www.hosthello.com/posts/puntatori</id><content type="html" xml:base="https://www.hosthello.com/posts/puntatori">&lt;p&gt;Un puntatore è come una normale variabile ma con un “potere” in più. Esso infatti non contiene dati in modo esplicito, ma &lt;strong&gt;contiene l’indirizzo di memoria&lt;/strong&gt; di un’altra variabile.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Il puntatore è una variabile di tipo indirizzo, ossia che contiene un indirizzo di memoria del calcolatore.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Essendo il puntatore una variabile va dichiarato allo stesso modo delle altre variabili.&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// dichiarazione puntatore&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// il puntatore può contenere solo indirizzi memoria&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;L’asterisco identifica che la variabile &lt;code class=&quot;highlighter-rouge&quot;&gt;ptr&lt;/code&gt; è un puntatore ossia una variabile capace di gestire valori &lt;strong&gt;alfanumerici&lt;/strong&gt; come gli indirizzi di memoria (es. 0x001001001028).&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Un variabile dichiarata come puntatore è l’unico elemento che può contenere un dato alfanumero e gestirlo come tale senza alterarne il significato.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;In questo caso la variabile è un puntatore ad &lt;code class=&quot;highlighter-rouge&quot;&gt;int&lt;/code&gt;: ciò significa che il contenuto gestibile da questa variabile puntatore dovrà essere un indirizzo di una &lt;strong&gt;cella di memoria&lt;/strong&gt; del calcolatore il cui contenuto sia un numero intero. Considerando che ci sono 3 protagonisti (la variabile puntatore, la variabile intera, il contenuto della varibile intera) il concetto sarà più chiaro avanti.&lt;/p&gt;

&lt;p&gt;Una volta dichiarato, è possibile maneggiare la variabile puntatore senza dover usare l’asterisco. Ma in alcuni casi vedremo che l’&lt;code class=&quot;highlighter-rouge&quot;&gt;*&lt;/code&gt; è necessario.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Dichiarare una variabile vuol dire &lt;strong&gt;assegnare&lt;/strong&gt; un indirizzo di memoria alla variabile.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;In questo momento il puntatore è stato dichiarato ma non inizializzato. Proviamo a vedere cosa contiene:&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// dichiarazione puntatore (ma non inizializzato)&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// stampo valore del puntatore&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;ptr = %p&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;//output&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;ptr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nil&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// oppure 0x7ffe71335ea0 (indirizzo a caso)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Il contenuto di un &lt;strong&gt;puntatore non inizializzato&lt;/strong&gt; dipende dalla macchina e &lt;strong&gt;non è&lt;/strong&gt; sempre lo stesso. Dato che un puntatore deve contenere indirizzi di memoria (diversamente sarebbe una normale variabile), se non inizializzato potrebbe contenere quanto segue:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;contenuto &lt;code class=&quot;highlighter-rouge&quot;&gt;(nil)&lt;/code&gt;: identifica che il puntatore non contiene nessun indirizzo di memoria&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;contenuto &lt;code class=&quot;highlighter-rouge&quot;&gt;0x7ffe71335ea0&lt;/code&gt;: un indirizzo di memoria &lt;strong&gt;scelto a caso dall’elaboratore&lt;/strong&gt;.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;       Memoria calcolatore   Indirizzi di memoria
      +-------------------+  ↑
      │         ...       │ ... 
      +-------------------+       
      │         ...       │ ...
      +-------------------+       
      │         ...       │ ...
      +-------------------+       
 ptr  │       (nil)       │ 0x001001001024
      +-------------------+        

// oppure

       Memoria calcolatore    
      +-------------------+       
      │         ...       │ 0x7ffe71335ea0
      +-------------------+   
      │         ...       │   
      +-------------------+       
      │         ...       │   
      +-------------------+
 ptr  │   0x7ffe71335ea0  │ 0x001001001024
      +-------------------+       
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Per identificare l’indirizzo memoria di una variabile si usa il carattere &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;amp;&lt;/code&gt; seguito dal nome variabile. Infatti se dichiariamo una varibile &lt;code class=&quot;highlighter-rouge&quot;&gt;var&lt;/code&gt; e vogliamo stamparne l’indirizzo di memoria (o indirizzo fisico) possiamo fare così:&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// dichiarazione variabile&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;var&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; 

&lt;span class=&quot;c1&quot;&gt;// stampo indirizzo memoria variabile&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&amp;amp;var = %p&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;var&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// output d'esempio: indirizzo memoria di var&lt;/span&gt;
&lt;span class=&quot;mh&quot;&gt;0x001001001028&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Ora, il puntatore per essere utile deve &lt;strong&gt;contenere&lt;/strong&gt; (in gergo puntare) un indirizzo di memoria di un’altra variabile. Come una normale variabile intera contiene un numero intero, un puntatore deve contenere un indirizzo di memoria. L’indirizzo di memoria non è un elemento “amichevole” da trovare per l’uomo, quindi per identificarlo si dichiara prima una variabile (ricordiamo che dichiarare una variabile vuol dire assegnare alla variabile una locazione della memoria, per cui un indirizzo di memoria) e poi si assegna l’indirizzo della variabile al puntatore (sappiamo già che l’indirizzo di una variabile si ottine con &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;amp;nomevar&lt;/code&gt;).&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;//dichiarazione e inizializzazione variabile &lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;//dichiarazione puntatore&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;//inizializzo puntatore assegnando l'indirizzo memoria della variabile var&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;ptr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;var&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Si può dichiarare e inizializzare in un’unica riga.&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;//dichiarazione e inizializzazione puntatore&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ptr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;var&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Cosa succede nella memoria del calcolatore.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;       Memoria calcolatore    
      +-------------------+       
      │         ...       │ 0x7ffe71335ea0
      +-------------------+      
      │         ...       │
      +-------------------+  
      │   0x001001001024  │
      │         ↓         │
      │ +---------------+ │
      │ │      100      │ │
 ptr  │ +---------------+ │ 0x001001001028
      +-------------------+  
 var  │        100        │ 0x001001001024
      +-------------------+
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Ora la variabile &lt;code class=&quot;highlighter-rouge&quot;&gt;ptr&lt;/code&gt; &lt;strong&gt;“punta”&lt;/strong&gt; (contiene l’indirizzo) alla variabile &lt;code class=&quot;highlighter-rouge&quot;&gt;var&lt;/code&gt;. Questo vuol dire che usando la variabile puntatore &lt;code class=&quot;highlighter-rouge&quot;&gt;ptr&lt;/code&gt; posso accedere al contenuto della variabile &lt;code class=&quot;highlighter-rouge&quot;&gt;var&lt;/code&gt;. Qualsiasi modifica fatta “tramite” il puntatore è come se venisse fatta alla variabile &lt;code class=&quot;highlighter-rouge&quot;&gt;var&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&quot;accedere-al-contenuto-della-variabile-var-tramite-puntatore-ptr&quot;&gt;Accedere al contenuto della variabile &lt;code class=&quot;highlighter-rouge&quot;&gt;var&lt;/code&gt; tramite puntatore &lt;code class=&quot;highlighter-rouge&quot;&gt;ptr&lt;/code&gt;.&lt;/h2&gt;

&lt;p&gt;Agire “tramite puntatore” non vuol dire “modificare il puntatore”. Questo concetto è importante e va capito bene. Vediamo di cosa si tratta.&lt;/p&gt;

&lt;p&gt;Per modificare il valore di &lt;code class=&quot;highlighter-rouge&quot;&gt;var&lt;/code&gt; &lt;strong&gt;tramite&lt;/strong&gt; il puntatore devo usare l’asterisco &lt;code class=&quot;highlighter-rouge&quot;&gt;*&lt;/code&gt; prima del nome variabile puntatore.&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// modifico var tramite il puntatore ptr&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ptr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;200&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Il codice sopra modifica il valore contenuto nella variabile &lt;code class=&quot;highlighter-rouge&quot;&gt;var&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Se &lt;strong&gt;non&lt;/strong&gt; si usa l’asterisco si modifica il contenuto della variabile &lt;code class=&quot;highlighter-rouge&quot;&gt;ptr&lt;/code&gt; che sappiamo deve essere un indirizzo memoria. Per cui è &lt;strong&gt;sbagliato&lt;/strong&gt; fare come segue per modificare il valore contenuto nella variabile &lt;code class=&quot;highlighter-rouge&quot;&gt;var&lt;/code&gt;.&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;//errato: così non si modifica il valore di var&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;ptr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;200&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Il codice sopra modifica il &lt;strong&gt;contenuto&lt;/strong&gt; della variabile &lt;code class=&quot;highlighter-rouge&quot;&gt;ptr&lt;/code&gt; che (essendo un puntatore) deve contenere &lt;strong&gt;indirizzi di memoria&lt;/strong&gt; (che sappiamo dargli usando &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;amp;var&lt;/code&gt;) e non valori interi, con virgola ecc…&lt;/p&gt;

&lt;p&gt;Al puntatore &lt;code class=&quot;highlighter-rouge&quot;&gt;ptr&lt;/code&gt; possiamo assegnare un altro indirizzo di memoria di un’altra variabile.&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;//dichiaro e inizializzo variabile&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;var2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;200&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;//cambio variabile puntata&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;ptr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;var2&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;codice-di-esempio&quot;&gt;Codice di esempio&lt;/h2&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;#include &amp;lt;stdio.h&amp;gt;
&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;argc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;argv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[])&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;//dichiarazione e inizializzazione variabile &lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

	&lt;span class=&quot;c1&quot;&gt;//dichiarazione puntatore&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

	&lt;span class=&quot;c1&quot;&gt;//inizializzo puntatore assegnando l'indirizzo memoria della variabile var&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;ptr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;var&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	
	&lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;Valore contenuto in var&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot; var = %i&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;var&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	
	&lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Valore contenuto in ptr&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot; ptr = %p (indirizzo memoria di var)&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

	&lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Indirizzo memoria di var&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; 
	&lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&amp;amp;var = %p&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;var&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

	&lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Indirizzo memoria di ptr&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; 
	&lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&amp;amp;ptr = %p&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

	&lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Contenuto puntato da ptr (valore contenuto in var)&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; 
	&lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;*ptr = %i&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

	&lt;span class=&quot;c1&quot;&gt;// dichiaro e inizializzo var2&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;var2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;200&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; 

	&lt;span class=&quot;c1&quot;&gt;//al puntatore assegno l'indirizzo memoria della variabile var2&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;ptr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;var2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

	&lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;Valore contenuto in var2&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot; var2 = %i&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;var2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	
	&lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Valore contenuto in ptr&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot; ptr = %p (indirizzo memoria di var2)&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

	&lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Indirizzo memoria di var2&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; 
	&lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&amp;amp;var2 = %p&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;var2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

	&lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Indirizzo memoria di ptr&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; 
	&lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&amp;amp;ptr = %p&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

	&lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Contenuto puntato da ptr (valore contenuto in var2)&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; 
	&lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;*ptr = %i&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;	
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>Ivan Garrini</name></author><summary type="html">Un puntatore è come una normale variabile ma con un “potere” in più. Esso infatti non contiene dati in modo esplicito, ma contiene l’indirizzo di memoria di un’altra variabile. Il puntatore è una variabile di tipo indirizzo, ossia che contiene un indirizzo di memoria del calcolatore. Essendo il puntatore una variabile va dichiarato allo stesso modo delle altre variabili. // dichiarazione puntatore // il puntatore può contenere solo indirizzi memoria int *ptr; L’asterisco identifica che la variabile ptr è un puntatore ossia una variabile capace di gestire valori alfanumerici come gli indirizzi di memoria (es. 0x001001001028). Un variabile dichiarata come puntatore è l’unico elemento che può contenere un dato alfanumero e gestirlo come tale senza alterarne il significato. In questo caso la variabile è un puntatore ad int: ciò significa che il contenuto gestibile da questa variabile puntatore dovrà essere un indirizzo di una cella di memoria del calcolatore il cui contenuto sia un numero intero. Considerando che ci sono 3 protagonisti (la variabile puntatore, la variabile intera, il contenuto della varibile intera) il concetto sarà più chiaro avanti. Una volta dichiarato, è possibile maneggiare la variabile puntatore senza dover usare l’asterisco. Ma in alcuni casi vedremo che l’* è necessario. Dichiarare una variabile vuol dire assegnare un indirizzo di memoria alla variabile. In questo momento il puntatore è stato dichiarato ma non inizializzato. Proviamo a vedere cosa contiene: // dichiarazione puntatore (ma non inizializzato) int *ptr; // stampo valore del puntatore printf(&quot;ptr = %p\n&quot;, ptr); //output ptr = (nil) // oppure 0x7ffe71335ea0 (indirizzo a caso) Il contenuto di un puntatore non inizializzato dipende dalla macchina e non è sempre lo stesso. Dato che un puntatore deve contenere indirizzi di memoria (diversamente sarebbe una normale variabile), se non inizializzato potrebbe contenere quanto segue: contenuto (nil): identifica che il puntatore non contiene nessun indirizzo di memoria contenuto 0x7ffe71335ea0: un indirizzo di memoria scelto a caso dall’elaboratore. Memoria calcolatore Indirizzi di memoria +-------------------+ ↑ │ ... │ ... +-------------------+ │ ... │ ... +-------------------+ │ ... │ ... +-------------------+ ptr │ (nil) │ 0x001001001024 +-------------------+ // oppure Memoria calcolatore +-------------------+ │ ... │ 0x7ffe71335ea0 +-------------------+ │ ... │ +-------------------+ │ ... │ +-------------------+ ptr │ 0x7ffe71335ea0 │ 0x001001001024 +-------------------+ Per identificare l’indirizzo memoria di una variabile si usa il carattere &amp;amp; seguito dal nome variabile. Infatti se dichiariamo una varibile var e vogliamo stamparne l’indirizzo di memoria (o indirizzo fisico) possiamo fare così: // dichiarazione variabile int var; // stampo indirizzo memoria variabile printf(&quot;&amp;amp;var = %p&quot;, &amp;amp;var); // output d'esempio: indirizzo memoria di var 0x001001001028 Ora, il puntatore per essere utile deve contenere (in gergo puntare) un indirizzo di memoria di un’altra variabile. Come una normale variabile intera contiene un numero intero, un puntatore deve contenere un indirizzo di memoria. L’indirizzo di memoria non è un elemento “amichevole” da trovare per l’uomo, quindi per identificarlo si dichiara prima una variabile (ricordiamo che dichiarare una variabile vuol dire assegnare alla variabile una locazione della memoria, per cui un indirizzo di memoria) e poi si assegna l’indirizzo della variabile al puntatore (sappiamo già che l’indirizzo di una variabile si ottine con &amp;amp;nomevar). //dichiarazione e inizializzazione variabile int var = 100; //dichiarazione puntatore int *ptr; //inizializzo puntatore assegnando l'indirizzo memoria della variabile var ptr = &amp;amp;var; Si può dichiarare e inizializzare in un’unica riga. //dichiarazione e inizializzazione puntatore int *ptr = &amp;amp;var; Cosa succede nella memoria del calcolatore. Memoria calcolatore +-------------------+ │ ... │ 0x7ffe71335ea0 +-------------------+ │ ... │ +-------------------+ │ 0x001001001024 │ │ ↓ │ │ +---------------+ │ │ │ 100 │ │ ptr │ +---------------+ │ 0x001001001028 +-------------------+ var │ 100 │ 0x001001001024 +-------------------+ Ora la variabile ptr “punta” (contiene l’indirizzo) alla variabile var. Questo vuol dire che usando la variabile puntatore ptr posso accedere al contenuto della variabile var. Qualsiasi modifica fatta “tramite” il puntatore è come se venisse fatta alla variabile var. Accedere al contenuto della variabile var tramite puntatore ptr. Agire “tramite puntatore” non vuol dire “modificare il puntatore”. Questo concetto è importante e va capito bene. Vediamo di cosa si tratta. Per modificare il valore di var tramite il puntatore devo usare l’asterisco * prima del nome variabile puntatore. // modifico var tramite il puntatore ptr *ptr = 200; Il codice sopra modifica il valore contenuto nella variabile var. Se non si usa l’asterisco si modifica il contenuto della variabile ptr che sappiamo deve essere un indirizzo memoria. Per cui è sbagliato fare come segue per modificare il valore contenuto nella variabile var. //errato: così non si modifica il valore di var ptr = 200; Il codice sopra modifica il contenuto della variabile ptr che (essendo un puntatore) deve contenere indirizzi di memoria (che sappiamo dargli usando &amp;amp;var) e non valori interi, con virgola ecc… Al puntatore ptr possiamo assegnare un altro indirizzo di memoria di un’altra variabile. //dichiaro e inizializzo variabile int var2 = 200; //cambio variabile puntata ptr = &amp;amp;var2 Codice di esempio #include &amp;lt;stdio.h&amp;gt; int main(int argc, char const *argv[]) { //dichiarazione e inizializzazione variabile int var = 100; //dichiarazione puntatore int *ptr; //inizializzo puntatore assegnando l'indirizzo memoria della variabile var ptr = &amp;amp;var; printf(&quot;\nValore contenuto in var\n&quot;); printf(&quot; var = %i\n\n&quot;, var); printf(&quot;Valore contenuto in ptr\n&quot;); printf(&quot; ptr = %p (indirizzo memoria di var)\n\n&quot;, ptr); printf(&quot;Indirizzo memoria di var\n&quot;); printf(&quot;&amp;amp;var = %p\n\n&quot;, &amp;amp;var); printf(&quot;Indirizzo memoria di ptr\n&quot;); printf(&quot;&amp;amp;ptr = %p\n\n&quot;, &amp;amp;ptr); printf(&quot;Contenuto puntato da ptr (valore contenuto in var)\n&quot;); printf(&quot;*ptr = %i\n\n&quot;, *ptr); // dichiaro e inizializzo var2 int var2 = 200; //al puntatore assegno l'indirizzo memoria della variabile var2 ptr = &amp;amp;var2; printf(&quot;\nValore contenuto in var2\n&quot;); printf(&quot; var2 = %i\n\n&quot;, var2); printf(&quot;Valore contenuto in ptr\n&quot;); printf(&quot; ptr = %p (indirizzo memoria di var2)\n\n&quot;, ptr); printf(&quot;Indirizzo memoria di var2\n&quot;); printf(&quot;&amp;amp;var2 = %p\n\n&quot;, &amp;amp;var2); printf(&quot;Indirizzo memoria di ptr\n&quot;); printf(&quot;&amp;amp;ptr = %p\n\n&quot;, &amp;amp;ptr); printf(&quot;Contenuto puntato da ptr (valore contenuto in var2)\n&quot;); printf(&quot;*ptr = %i\n\n&quot;, *ptr); }</summary></entry><entry><title type="html">Array e puntatori</title><link href="https://www.hosthello.com/posts/array-e-puntatori" rel="alternate" type="text/html" title="Array e puntatori" /><published>2017-05-27T00:00:00+02:00</published><updated>2017-05-27T00:00:00+02:00</updated><id>https://www.hosthello.com/posts/array-e-puntatori</id><content type="html" xml:base="https://www.hosthello.com/posts/array-e-puntatori">&lt;p&gt;Di seguito un esempio sulla differenza d’uso su come gli array possono essere gestiti con l’uso di puntatori, a dimostrazione di come (array e puntatore) siano due elementi equivalenti tra loro.&lt;/p&gt;

&lt;h2 id=&quot;versione-con-array&quot;&gt;Versione con array&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;

//prototipi (o firme)
void riempiArray( int [] );
void stampaArray( int [] );

int main(){
    int array[5] ;
    riempiArray( array );
    stampaArray( array );
}

void riempiArray( int a[] ){
    int i; 
    for(i = 0; i &amp;lt; 5; i++){
        a[i] = i;
    }
}

void stampaArray( int a[] ){
    int i; 
    printf(&quot;array { &quot;);
    for(i = 0; i &amp;lt; 5; i++){
        printf(&quot;%i &quot;, a[i] ) ;
    }
    printf(&quot;}\n&quot;);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Il codice sopra è un tipico esempio di come un array viene gestito. Nel &lt;code class=&quot;highlighter-rouge&quot;&gt;main&lt;/code&gt; vengono richiamate le funzioni:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;riempiArray( array );
stampaArray( array );
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Il parametro passato alle due funzioni è il nome dell’array (in qeusto caso il nome è proprio &lt;code class=&quot;highlighter-rouge&quot;&gt;array&lt;/code&gt;). Possiamo scrivere in modo del tutto equivalente al precedente, il seguente codice:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;riempiArray( &amp;amp;array[0] );
stampaArray( &amp;amp;array[0] );
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;dove &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;amp;array[0]&lt;/code&gt; sarebbe l’indirizzo di memoria (indirizzo fisico) del &lt;strong&gt;primo&lt;/strong&gt; elemento del’array. Per cui passare &lt;code class=&quot;highlighter-rouge&quot;&gt;array&lt;/code&gt; o &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;amp;array[0]&lt;/code&gt; è la stessa cosa. &lt;strong&gt;Infatti quando si passa il nome dell’array ad una funzione è come se venisse passato l’indirizzo del primo elemento dell’array&lt;/strong&gt;.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//il nome di un array corrisponde all'indirizzo 
//dell'elemento in posizione 0 dell'array stesso
array == &amp;amp;array[0]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Il &lt;strong&gt;prototipo&lt;/strong&gt; delle funzioni seguenti&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;riempiArray&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;stampaArray&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;equivale al seguente prototipo:&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;riempiArray&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;stampaArray&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Il parametro formale &lt;code class=&quot;highlighter-rouge&quot;&gt;( int * )&lt;/code&gt; o il parametro formale &lt;code class=&quot;highlighter-rouge&quot;&gt;( int [] )&lt;/code&gt; sono la stessa cosa. Entrambi i parametri richiedono  che il valore sia un &lt;strong&gt;indirizzo di memoria&lt;/strong&gt;.&lt;/p&gt;

&lt;h2 id=&quot;versione-con-aritmetica-puntatori&quot;&gt;Versione con aritmetica puntatori&lt;/h2&gt;

&lt;p&gt;A fronte di quanto già visto, di seguito è riportata una versione del codice precedente che fa uso dei puntatori.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;

//prototipi (o firma)
void riempiArray( int * );
void stampaArray( int ** );

int main(){
    //dichiaro array
    int array[5] ;
    int * arrayPtr = array;
    riempiArray( &amp;amp;array[0] ); //equivalente a riempiArray( array );
    stampaArray( &amp;amp;arrayPtr );
}

void riempiArray( int *a ){
/* Equivalente
void riempiArray( int a [] ){   
*/
    int i; 
    for(i = 0; i &amp;lt; 5; i++){
        a[i] = i;
    }
}

void stampaArray( int **a ){
    int i; 
    printf(&quot;array { &quot;);
    for(i = 0; i &amp;lt; 5; i++){
        printf(&quot;%i &quot;, *(*a + i) ) ;
    /*  equivalente
        printf(&quot;%i &quot;, *(*a + i) ) ;  
    */
    }
    printf(&quot;}\n&quot;);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;I prototipi delle funzioni sono i seguenti:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//prototipi (o firma)
void riempiArray( int * );
void stampaArray( int ** );
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Sebbene le funzioni facciano la stessa cosa, ossia (come visto nell’esempio precedente) lavorare su un array di interi, le loro firme sono state modificate per scopi didattici.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void riempiArray( int * );
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Nella prima firma (come già detto in precedenza) è rischiesto che alla funzione venga passato un &lt;strong&gt;indirizzo di una cella memoria&lt;/strong&gt; che al suo interno contenga un valore &lt;strong&gt;intero&lt;/strong&gt;. L’asterisco identifica proprio che il parametro passato &lt;strong&gt;deve essere trattato&lt;/strong&gt; come un indirizzo di memoria! Se guardiamo nel &lt;code class=&quot;highlighter-rouge&quot;&gt;main&lt;/code&gt;, quando si richiama la funzione, viene passato l’indirizzo dell’array, ossia l’indirizzo del primo elemento dell’array &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;amp;array[0]&lt;/code&gt;.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void stampaArray( int ** );
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Nella seconda firma troviamo due asterischi. La firma richiede che alla funzione venga passato un &lt;strong&gt;indirizzo di una cella memoria&lt;/strong&gt; che al suo interno contenga un altro &lt;strong&gt;indirizzo di una cella memoria&lt;/strong&gt; che al suo interno contenga un valore intero.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// la memoria e il doppio asterisco

            Memoria calcolatore    
           +-------------------+       
     ...   │         ...       │  ...            
           +-------------------+       
 array[1]  │         200       │ 0x001001001036 (== &amp;amp;array[1])
           +-------------------+      
    array  │         100       │ 0x001001001028 (== &amp;amp;array[0])
           +-------------------+  
 arrayPtr  │      &amp;amp;array[0]    │ 0x001001001024 (== &amp;amp;arrayPtr )
           +-------------------+

// equivale al seguente

            Memoria calcolatore    
           +-------------------+       
     ...   │         ...       │  ...            
           +-------------------+       
 array[1]  │         200       │ 0x001001001036 (== &amp;amp;array[1])
           +-------------------+      
    array  │         100       │ 0x001001001028 (== &amp;amp;array[0])
           +-------------------+  
 arrayPtr  │   0x001001001028  │ 0x001001001024 (== &amp;amp;arrayPtr )
           +-------------------+
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Si chiama doppio puntatore o puntatore di puntatore ed è importante capirlo perchè usato (ad es.) nelle matrice allocate dinamicamente (matrici che in fase di esecuzione possono aumentare o diminuire l’uso della memoria in base alla necessità e  &lt;strong&gt;senza&lt;/strong&gt; dover ricompilare il programma - es. per aumentare il numero elementi della matrice -). Ovviamente può esistere anche un triplo puntatore ecc…&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    // main
    // dichiarazione puntatore
    int * arrayPtr = array; // oppure int * arrayPtr = &amp;amp;array[0];
    ...
    //richiamo funzione passandogli un'indirizzo 
    stampaArray( &amp;amp;arrayPtr );
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Se guardiamo nel &lt;code class=&quot;highlighter-rouge&quot;&gt;main&lt;/code&gt; vediamo che per passare un indirizzo contenente un altro indirizzo, bisogna dichiarare un puntatore perchè è &lt;strong&gt;l’unico mezzo disponibile capace di contenere un indirizzo di memoria&lt;/strong&gt; senza alterarne il significato.&lt;/p&gt;

&lt;p&gt;Infatti usare il codice sotto porterebbe ad un errore di compilazione dato che si sta inserendo l’indirizzo del primo elemento dell’array (&lt;code class=&quot;highlighter-rouge&quot;&gt;array&lt;/code&gt; equivale ad &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;amp;array[0]&lt;/code&gt;) in una varibile che deve contenere solo valori interi.&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;//errato&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;arrayPtr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;//si sta inserendo un valore alfanumerico 0x001001001028 &lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//in una variabile che richiede solo valori numerici&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;passare-ad-una-funzione-un-indirizzo-di-memoria&quot;&gt;Passare ad una funzione un indirizzo di memoria&lt;/h3&gt;

&lt;p&gt;Per capire meglio il concetto di passare un indirizzo di memoria ad una funzione guardiamo il codice sotto.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// firma
void riempiArray( int * );

...

// richiamo funzione nel main
riempiArray( 0x001001001028 );
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Sapendo che la funzione richiede un indirizzo di memoria come parametro, nulla vieta di poter passare alla funzione un vero indirizzo di memoria. Ma il problema è che l’uomo non ha accesso facile agli indirizzi di memoria che sono di gestione del calcolatore.&lt;/p&gt;

&lt;p&gt;Il codice sopra non è errato, ma richiederebbe la conoscenza dell’indirizzo da passare alla funzione. Gestire tale cosa in questo modo è improponibile dato che bisognerebbe scrivere ogni volta “a mano” l’indirizzo di memoria (che tra l’altro cambia in modo continuo sul calcolatore) e ricompilare il programma.&lt;/p&gt;

&lt;p&gt;Per cui si usa il segno &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;amp;&lt;/code&gt; davanti alla variabile, &lt;code class=&quot;highlighter-rouge&quot;&gt;array[0]&lt;/code&gt; ecc… che permette di estrapolare l’indirizzo di memoria in modo automatico.&lt;/p&gt;</content><author><name>Ivan</name></author><summary type="html">Di seguito un esempio sulla differenza d’uso su come gli array possono essere gestiti con l’uso di puntatori, a dimostrazione di come (array e puntatore) siano due elementi equivalenti tra loro. Versione con array #include &amp;lt;stdio.h&amp;gt; //prototipi (o firme) void riempiArray( int [] ); void stampaArray( int [] ); int main(){ int array[5] ; riempiArray( array ); stampaArray( array ); } void riempiArray( int a[] ){ int i; for(i = 0; i &amp;lt; 5; i++){ a[i] = i; } } void stampaArray( int a[] ){ int i; printf(&quot;array { &quot;); for(i = 0; i &amp;lt; 5; i++){ printf(&quot;%i &quot;, a[i] ) ; } printf(&quot;}\n&quot;); } Il codice sopra è un tipico esempio di come un array viene gestito. Nel main vengono richiamate le funzioni: riempiArray( array ); stampaArray( array ); Il parametro passato alle due funzioni è il nome dell’array (in qeusto caso il nome è proprio array). Possiamo scrivere in modo del tutto equivalente al precedente, il seguente codice: riempiArray( &amp;amp;array[0] ); stampaArray( &amp;amp;array[0] ); dove &amp;amp;array[0] sarebbe l’indirizzo di memoria (indirizzo fisico) del primo elemento del’array. Per cui passare array o &amp;amp;array[0] è la stessa cosa. Infatti quando si passa il nome dell’array ad una funzione è come se venisse passato l’indirizzo del primo elemento dell’array. //il nome di un array corrisponde all'indirizzo //dell'elemento in posizione 0 dell'array stesso array == &amp;amp;array[0] Il prototipo delle funzioni seguenti void riempiArray( int [] ); void stampaArray( int [] ); equivale al seguente prototipo: void riempiArray( int * ); void stampaArray( int * ); Il parametro formale ( int * ) o il parametro formale ( int [] ) sono la stessa cosa. Entrambi i parametri richiedono che il valore sia un indirizzo di memoria. Versione con aritmetica puntatori A fronte di quanto già visto, di seguito è riportata una versione del codice precedente che fa uso dei puntatori. #include &amp;lt;stdio.h&amp;gt; //prototipi (o firma) void riempiArray( int * ); void stampaArray( int ** ); int main(){ //dichiaro array int array[5] ; int * arrayPtr = array; riempiArray( &amp;amp;array[0] ); //equivalente a riempiArray( array ); stampaArray( &amp;amp;arrayPtr ); } void riempiArray( int *a ){ /* Equivalente void riempiArray( int a [] ){ */ int i; for(i = 0; i &amp;lt; 5; i++){ a[i] = i; } } void stampaArray( int **a ){ int i; printf(&quot;array { &quot;); for(i = 0; i &amp;lt; 5; i++){ printf(&quot;%i &quot;, *(*a + i) ) ; /* equivalente printf(&quot;%i &quot;, *(*a + i) ) ; */ } printf(&quot;}\n&quot;); } I prototipi delle funzioni sono i seguenti: //prototipi (o firma) void riempiArray( int * ); void stampaArray( int ** ); Sebbene le funzioni facciano la stessa cosa, ossia (come visto nell’esempio precedente) lavorare su un array di interi, le loro firme sono state modificate per scopi didattici. void riempiArray( int * ); Nella prima firma (come già detto in precedenza) è rischiesto che alla funzione venga passato un indirizzo di una cella memoria che al suo interno contenga un valore intero. L’asterisco identifica proprio che il parametro passato deve essere trattato come un indirizzo di memoria! Se guardiamo nel main, quando si richiama la funzione, viene passato l’indirizzo dell’array, ossia l’indirizzo del primo elemento dell’array &amp;amp;array[0]. void stampaArray( int ** ); Nella seconda firma troviamo due asterischi. La firma richiede che alla funzione venga passato un indirizzo di una cella memoria che al suo interno contenga un altro indirizzo di una cella memoria che al suo interno contenga un valore intero. // la memoria e il doppio asterisco Memoria calcolatore +-------------------+ ... │ ... │ ... +-------------------+ array[1] │ 200 │ 0x001001001036 (== &amp;amp;array[1]) +-------------------+ array │ 100 │ 0x001001001028 (== &amp;amp;array[0]) +-------------------+ arrayPtr │ &amp;amp;array[0] │ 0x001001001024 (== &amp;amp;arrayPtr ) +-------------------+ // equivale al seguente Memoria calcolatore +-------------------+ ... │ ... │ ... +-------------------+ array[1] │ 200 │ 0x001001001036 (== &amp;amp;array[1]) +-------------------+ array │ 100 │ 0x001001001028 (== &amp;amp;array[0]) +-------------------+ arrayPtr │ 0x001001001028 │ 0x001001001024 (== &amp;amp;arrayPtr ) +-------------------+ Si chiama doppio puntatore o puntatore di puntatore ed è importante capirlo perchè usato (ad es.) nelle matrice allocate dinamicamente (matrici che in fase di esecuzione possono aumentare o diminuire l’uso della memoria in base alla necessità e senza dover ricompilare il programma - es. per aumentare il numero elementi della matrice -). Ovviamente può esistere anche un triplo puntatore ecc… // main // dichiarazione puntatore int * arrayPtr = array; // oppure int * arrayPtr = &amp;amp;array[0]; ... //richiamo funzione passandogli un'indirizzo stampaArray( &amp;amp;arrayPtr ); Se guardiamo nel main vediamo che per passare un indirizzo contenente un altro indirizzo, bisogna dichiarare un puntatore perchè è l’unico mezzo disponibile capace di contenere un indirizzo di memoria senza alterarne il significato. Infatti usare il codice sotto porterebbe ad un errore di compilazione dato che si sta inserendo l’indirizzo del primo elemento dell’array (array equivale ad &amp;amp;array[0]) in una varibile che deve contenere solo valori interi. //errato int arrayPtr = array; //si sta inserendo un valore alfanumerico 0x001001001028 //in una variabile che richiede solo valori numerici Passare ad una funzione un indirizzo di memoria Per capire meglio il concetto di passare un indirizzo di memoria ad una funzione guardiamo il codice sotto. // firma void riempiArray( int * ); ... // richiamo funzione nel main riempiArray( 0x001001001028 ); Sapendo che la funzione richiede un indirizzo di memoria come parametro, nulla vieta di poter passare alla funzione un vero indirizzo di memoria. Ma il problema è che l’uomo non ha accesso facile agli indirizzi di memoria che sono di gestione del calcolatore. Il codice sopra non è errato, ma richiederebbe la conoscenza dell’indirizzo da passare alla funzione. Gestire tale cosa in questo modo è improponibile dato che bisognerebbe scrivere ogni volta “a mano” l’indirizzo di memoria (che tra l’altro cambia in modo continuo sul calcolatore) e ricompilare il programma. Per cui si usa il segno &amp;amp; davanti alla variabile, array[0] ecc… che permette di estrapolare l’indirizzo di memoria in modo automatico.</summary></entry></feed>